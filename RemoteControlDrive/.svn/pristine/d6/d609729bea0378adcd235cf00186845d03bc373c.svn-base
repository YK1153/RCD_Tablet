using RcdCmn;
using RcdDao;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using AtrptShare;
using AtrptCalc;
using System.Threading;
using CommWrapper;
using System.Drawing;
using static RcdDao.MPLCDao;
using RcpOperation.Common;
using RcdOperationSystemConst;
using static RcdDao.MCourseDao;
using static RcdDao.MCourseAreaDao;
using static RcdDao.MCourseNodeDao;
using static RcdDao.MCarSpecDao;
using static RcdDao.MFacilityDao;
using RcdOperation.PlcControl;
using System.Timers;
using static RcdDao.MSystemValue;
using System.Windows.Forms;
using MapViewer;

namespace RcdOperation.Control
{
    public partial class ControlMain : Form
    {
        private System.Threading.Timer m_timer_cc;
        private clsCalculator m_calc;

        /// <summary>
        /// 車両情報送信タイマー
        /// </summary>
        private System.Threading.Timer m_timer_ci;
        private int m_ci_interval = 100;

        private PointF m_newPPoint = new PointF();
        /// <summary>
        /// 連続異常測位点カウント
        /// </summary>
        private int m_ErrCnt = 0;

        DateTime m_now;
        /// <summary>
        /// 車両制御状態 1:制御中 ※見直し
        /// </summary>
        private int m_CarControlStatus = 0;
        /// <summary>
        /// 異常検知状態 true:異常検知中
        /// </summary>
        private bool m_EmergencyStop;
        /// <summary>
        /// 車両制御送信開始 0:未
        /// </summary>
        private int m_calcstarted = 0;
        private bool m_GoalCheckSnd = false;
        /// <summary>
        /// 制御状態 0:正常 1:異常
        /// </summary>
        private int m_error_flg = 0;
        /// <summary>
        /// ゴール状況
        /// </summary>
        private int m_goal_flg = 0;
        /// <summary>
        /// 一時停止状態 0:正常 1:一時停止
        /// </summary>
        private int m_pause_flg = 0;
        /// <summary>
        /// 一時停止状態(ゴール判定) 0:正常 1:一時停止
        /// </summary>
        private int m_pause_goal_flg = 0;
        /// ゴール後停止状況
        /// </summary>
        private int m_goalcomp_flg = 0;
        /// <summary>
        /// 在籍センサ確認
        /// </summary>
        private bool m_senser_check = true;
        /// <summary>
        /// 範囲外回数
        /// </summary>
        int m_outarea;
        private OtherAreaRetention[] m_otherArea;
        private ConfigData m_ConfigData = new ConfigData();
        private ControlCenterData m_controlCenterData = new ControlCenterData();
        private string m_TerminalStatus;
        private object m_carcontrollock = new object();
        private AVPAppOutputData m_avpappOutputData = new AVPAppOutputData();
        private ObservedData m_observedData = new ObservedData();

        private TimeSpan m_sertimespan;


        private AtrptShare.CarSpec m_carSpec = new AtrptShare.CarSpec();

        //private double m_carAngle = new double();

        private string[] m_cornername = { "左後端", "左前端", "右前端", "右後端" };

        public List<RouteNode> m_RouteNodes = new List<RouteNode>();
        public List<SpeedArea> m_SpeedAreas = new List<SpeedArea>();
        
        private int m_contain_idx = -1;
        List<CarCornerinfo> m_CarCornerinfo = new List<CarCornerinfo>();

        #region ### 共通クラス変数 ###
        AppLog LOGGER = AppLog.GetInstance();
        int m_stationNo;
        public ConnectionConst m_connectionConst;

        //Cam
        OperationConst.CamType MainCamType = OperationConst.CamType.Pana; //　※
        OperationConst.CamType SubCamType = OperationConst.CamType.AVP; //　※

        CommCam m_camClPana;
        CommCam m_camClWco;

        /// <summary> 全コースマスタ情報 </summary>
        List<CourseInfo> m_CourseInfoList;

        // Status
        CarInfo m_CarInfo = new CarInfo();

        // CarSpec
        internal List<MCarSpec> m_carSpecs;

        // PLC
        internal List<PLCDeviceInfo> m_plc_debice;
        internal List<PLCUnitStatus> m_plcunit;
        internal PLCControl m_PLCControl;

        // Facility
        internal List<FacilityType> m_facilityTypes;
        internal List<FacilityStatusMsg> m_facilityStatusMsgs;
        internal Dictionary<string, FacilityStatus> m_dicFacilityStatus;

        // Threads
        internal List<FacilityControl> m_facilityControlThreads;
        internal List<FacilityControl> m_facControlWaits;

        // Message
        private List<SystemMessage> m_SystemMsg;

        // SystemTimer
        private System.Timers.Timer m_plcstatusLogTimer;

        // Status
        internal List<FacilityStatus> m_FacilityStatus;



        //
        private List<CamList> m_camList;
        #endregion

        #region ### クラス変数 ###
        /// <summary>
        /// 制御中車両ボデーNo
        /// </summary>
        private string m_CarNo = "";
        private string m_CarSpec = "";

        #endregion

        #region ### コンストラクタ ###
        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="StationNo">工程番号</param>
        public ControlMain(int StationNo,ConnectionConst Const)
        {
            AppLog.GetInstance().Debug($"OperationMain StationoNo:{StationNo} constructor start");

            InitializeComponent();

            LOGGER.Info($"起動");

            //※初期処理　※一時対応
            Dummy_firstprocess();

            //値受取
            m_stationNo = StationNo;
            m_connectionConst = Const;

            //DBデータ取得ー初期化
            //InitStatus();

            //接続セット～接続
            ConnectSet();

            //現在の制御モード同期



            

            // 表示画像セット
            SetViewConfig();

            AppLog.GetInstance().Debug($"OperationMain StationoNo:{StationNo} constructor end");
        }


        /// <summary>
        /// DB情報取得
        /// </summary>
        private void InitStatus()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            //マスタ情報取得

            //車両仕様情報取得
            m_carSpecs = new MCarSpecDao().GetAllCarSpecsInfo();

            // PLC情報取得
            MPLCDao fPLCDao = new MPLCDao();
            m_plc_debice = fPLCDao.GetAllPLCDevice();
            m_plcunit = new List<PLCUnitStatus>();
            foreach (PLCDeviceInfo plc in m_plc_debice)
            {
                m_plcunit.Add(new PLCUnitStatus(plc));
            }

            // 全コース情報取得
            List<Course> courselist = new List<Course>();
            m_CourseInfoList = new List<CourseInfo>();
            foreach (Course course in courselist)
            {
                m_CourseInfoList.Add(new CourseInfo(course));
            }

            //設備情報取得
            MFacilityDao fDao = new MFacilityDao();
            m_facilityControlThreads = new List<FacilityControl>();

            List<SettingMap> settingMaps = fDao.GetAllrFacilityCtrlMap();

            m_facilityTypes = fDao.GetAllFacilityTypes();
            m_facilityStatusMsgs = fDao.GetFacilityStatusMsgs();

            List<RFacility> rFacilities = fPLCDao.GetAllrFacilityInfo();
            List<RPLCBitSetting> rPLCBitSettings = fPLCDao.GetAllrPLCBitSettings();

            PLCControl.Initialize(rFacilities, rPLCBitSettings, settingMaps, m_plcunit, m_MAX_IO_READ_WAIT);
            m_PLCControl = PLCControl.GetInstance();
            //PLCステータスDB記録
            m_plcstatusLogTimer = new System.Timers.Timer
            {
                Interval = m_STATUS_UPDATE_INTERVAL
            };
            m_plcstatusLogTimer.Elapsed += OnPlcStatusLogTimerElapsed;
            m_plcstatusLogTimer.Start();


            //システムメッセージ取得
            m_SystemMsg = new MSystemValue().GetSystemMsgOf();


            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        /// <summary>
        /// 接続情報初期化
        /// </summary>
        private void ConnectSet()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            // ManagementPCへ接続
            //CommManagement();

            // 自走TVECSへ接続
            SetCommTvecs();

            // Pana画像解析へ接続
            m_camClPana = new CommCam(m_connectionConst,OperationConst.CamType.Pana);
            m_camClPana.Emergency += new CommCam.EmergencyEndProcessEventHundler(EventChatchEmergency);
            m_camClPana.StartErr += new CommCam.EmergencyEndProcessEventHundler(EventChatchControlStartStatus);
            m_camClPana.CamChange += new CommCam.AnalyzerCamNoChangedEventHundler(SafetyMonitoringCamNoChange);

            // WCo画像解析へ接続
            m_camClWco = new CommCam(m_connectionConst, OperationConst.CamType.AVP);
            m_camClWco.Emergency += new CommCam.EmergencyEndProcessEventHundler(EventChatchEmergency);
            m_camClWco.StartErr += new CommCam.EmergencyEndProcessEventHundler(EventChatchControlStartStatus);
            m_camClWco.CamChange += new CommCam.AnalyzerCamNoChangedEventHundler(SafetyMonitoringCamNoChange);

            // 物体検知へ接続
            InitializeSafetyMonitoring();

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }
        #endregion

        #region ### Dispose ###
        public void Dispose()
        {
            m_camClPana.Dispose();
            m_camClWco.Dispose();

            if (m_tcl != null) m_tcl.Disconnect(true);
            if (m_tsrv != null) m_tsrv.EndListen(true);

            if (m_detectCl != null) m_detectCl.Dispose();

            m_facilityControlThreads.ForEach(cThread => cThread.m_reset.Dispose());
        }
        #endregion

        #region ### フォームロード / クローズイベント ###
        private void ControlMain_Load(object sender, EventArgs e)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            m_TerminalStatus = Res.CtrlStatus.IDLE.Code;



            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }


        private void ControlMain_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.Visible = false;
            }
        }
        #endregion

        #region ### 走行状態管理 ###
        private string TerminalHealthCheck()
        {
            //制御していないときのみ開始できるか確認する
            if (m_CarControlStatus == OperationConst.ControlStatusType.C_NOT_IN_CONTROL)
            {
                string status = Res.CtrlStatus.CTRL_AVAILABLE.Code;

                //画像接続確認
                if (GetCamCommStatus(MainC)) { return Res.CtrlStatus.CAM_CONNECTION_ERR.Code; }
                if (GetCamCommStatus(SubC)) { return Res.CtrlStatus.CAM_CONNECTION_ERR.Code; }

                //カメラ確認
                if (GetCamHeakthStatus(MainC) == 1) { return Res.CtrlStatus.CAM_ERR.Code; }
                if (GetCamHeakthStatus(SubC) == 1) { return Res.CtrlStatus.CAM_ERR.Code; }

                //車両接続確認
                if (TvecsCommClStatus || TvecsCommSrvStatus) { return Res.CtrlStatus.CAR_CONNECTION_ERR.Code; }

                //走行停止中か
                if (m_EmergencyStop) { return Res.CtrlStatus.STOPPING.Code; }

                return status;
            }
            //制御中
            if (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL)
            {
                uint status = GetPauseStatus();

                if (status == OperationConst.AccelerationStatus.C_ACCELERATION_PAUSE)
                {
                    if (m_CarInfo.speed == 0)
                    {
                        //StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_PAUSE);
                        return Res.CtrlStatus.PAUSED.Code;
                    }
                    else
                    {
                        //StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_PAUSE);
                        return Res.CtrlStatus.PAUSING.Code;
                    }
                }
                else if(status == OperationConst.AccelerationStatus.C_ACCELERATION_EMERGENCY)
                {
                    //StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_ERROR);
                    return Res.CtrlStatus.STOPPING.Code;
                }
                else
                {
                    //StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_RUNNING);
                }
            }

            return m_TerminalStatus;
        }
        #endregion

        #region ### 制御開始時初期化 ###
        public void ResetVal()
        {
            m_CarInfo.xPosition = -1;
            m_CarInfo.yPosition = -1;

            m_error_flg = 0;
            m_EmergencyStop = false;
            m_GoalCheckSnd = false;
            m_goalcomp_flg = 0;

            m_contain_idx = -1;
            List<CarCornerinfo> m_CarCornerinfo = new List<CarCornerinfo>();


            //初期化呼び出し
            TvecsResetVal();
            ExeCamResetVal(MainC);
            DrowInitialize();
        }
        #endregion

        #region ### 自走前検査 ###
        /// <summary>
        /// 自走前検査シーケンス
        /// </summary>
        public void SelfPropelledInspection()
        {
            // RFID読み込み
            //bool result = RFID();
            //// 要求結果がNGの場合RQコード読取

            // 検査情報確認
            //result = Inspection();

            // 端末切替と画角ズレを並行動作
            //// TVECS端末切替

            //// 画角ズレ検査
            m_camClPana.ViewAngleShiftCheckAll();
            //m_camClWco.ViewAngleShiftCheckAll();

            // 処理終了待機



            //※ 位置検討
            ControlStartProc();
        }

        /// <summary>
        /// 自走検査時に走行NGとなった場合の処理を記載
        /// </summary>
        public void SelfPropelledNGProc()
        {
            //PLCに不可であることを出力


        }

        #endregion

        #region ### 送受信ログ出力 ###
        public class LogWriteComm : ICommLogWriter
        {
            private string m_name = "";
            private string m_string = "";

            public LogWriteComm(string name, string s)
            {
                m_name = name;
                m_string = s;
            }

            public void WriteCommLog(byte[] data)
            {
                AppLog.GetInstance().Info($"[{m_name},{m_string}]：{Encoding.ASCII.GetString(data)}");
            }
        }
        #endregion

        #region ### 制御エリア判定用クラス ###
        public class OtherAreaRetention
        {
            /// <summary>
            /// その他エリア
            /// </summary>
            public OtherArea otherarea { get; set; }
            /// <summary>
            /// 次処理インデックス
            /// </summary>
            public int Done { get; set; }
            /// <summary>
            /// 設備ステータス 0:動作前 1:動作後
            /// </summary>
            public int status { get; set; }
            /// <summary>
            /// 一時停止エリア侵入
            /// </summary>
            public bool stop { get; set; }
        }
        #endregion

        #region ### 一時停止状態取得 ###
        /// <summary>
        /// 一時停止の条件を満たしているかの状態を返す
        /// センサ等による停止
        /// メイン測位受信遅延
        /// サブ測位受信遅延
        /// TVECS通信受信遅延
        /// ゴール満
        /// 侵入検知
        /// </summary>
        /// <returns></returns>
        private uint GetPauseStatus()
        {

            //状況に応じて加速度を変更する
            if (m_pause_flg == OperationConst.C_ABNORMAL || m_pause_goal_flg == OperationConst.C_ABNORMAL || m_pause_detect_flg == OperationConst.C_ABNORMAL)
            {
                LOGGER.Info($"[一時停止]{m_pause_flg}{m_pause_goal_flg}");
                return OperationConst.AccelerationStatus.C_ACCELERATION_PAUSE;
            }
            if (GetPauseStatus(MainC) == OperationConst.C_ABNORMAL || GetPauseStatus(SubC) == OperationConst.C_ABNORMAL || m_pause_commT_flg == OperationConst.C_ABNORMAL)
            {
                LOGGER.Info($"[一時停止通信途絶）]{GetPauseStatus(MainC)}{GetPauseStatus(SubC)}{m_pause_commT_flg}");
                return OperationConst.AccelerationStatus.C_ACCELERATION_PAUSE_DISCONNECTION;
            }
            if (m_goal_flg == 1)
            {
                LOGGER.Info($"[ゴール範囲]{m_goal_flg}");
                return OperationConst.AccelerationStatus.C_ACCELERATION_GOAL;
            }
            if (m_error_flg == 1 || GetCamHeakthStatus(MainC) == 1 || GetCamHeakthStatus(SubC) == 1)
            {
                LOGGER.Info($"[異常]");
                return OperationConst.AccelerationStatus.C_ACCELERATION_EMERGENCY;
            }

            return OperationConst.AccelerationStatus.C_ACCELERATION_NOMAL;
        }
        #endregion

        #region PLC設備ステータス記録
        /// <summary>
        /// ステータス記録タイマー処理(PLC直)
        /// </summary>
        private void OnPlcStatusLogTimerElapsed(object sender, ElapsedEventArgs e)
        {
            LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
            LOGGER.Debug($"設備ステータス更新");
            try
            {
                m_plcstatusLogTimer.Stop();

                Dictionary<PLCDeviceInfo, List<byte[]>> inputs = new Dictionary<PLCDeviceInfo, List<byte[]>>();
                Dictionary<PLCDeviceInfo, List<byte[]>> outputs = new Dictionary<PLCDeviceInfo, List<byte[]>>();
                //接点読取
                foreach (PLCUnitStatus plc in m_plcunit)
                {
                    if (plc.Connected == PLCUnitStatus.ConnectStatus.Connected)
                    {
                        if (plc.ReadContactStatus.Count > 0) { inputs[plc.PLCInfo] = plc.ReadContactStatus; }
                        if (plc.ReadContactStatus.Count > 0) { outputs[plc.PLCInfo] = plc.WriteContactStatus; }
                    }
                }

                //PLC確認ステータス
                //Task.Run(() =>
                //{
                //    UpdatePLCWatchStatus(inputs);
                //    CheckPLCAll();
                //});

                //設備ステータス
                List<FacilityStatus> facStatusList = m_PLCControl.GetAllFacilityStatus(inputs, outputs);
                m_dicFacilityStatus = facStatusList.ToDictionary(fac => fac.FacilityID);

                m_FacilityStatus = facStatusList;
                

                //設備の状態から、処理を判定する
                //FacilityStatusCheck(facStatusList);

            }
            catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
            catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
            finally
            {
                if (m_plcstatusLogTimer != null) m_plcstatusLogTimer.Start();
                LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End");
            }
        }

        #region

        //private void FacilityStatusCheck(List<FacilityStatus> facStatusList)
        //{
        //    // 走行停止設備確認
        //    Task.Run(() =>
        //    {
        //        CheckStopBtnError(facStatusList);
        //    });

        //    // エリアセンサ確認
        //    Task.Run(() =>
        //    {
        //        CheckAreaSensorPause(facStatusList);
        //    });

        //    // エリアセンサ解除確認
        //    Task.Run(() =>
        //    {
        //        CheckAreaSensorPauseCancel(facStatusList);
        //    });

        //    // ゴールエリア更新
        //    Task.Run(() =>
        //    {
        //        UpdateGoalAreaNo(facStatusList);
        //    });

        //    // 各個連続表示更新
        //    Task.Run(() =>
        //    {
        //        UpdateManagerModeFacility(facStatusList);
        //    });

        //    // ステータス取得不可確認
        //    Task.Run(() =>
        //    {
        //        CheckDIOFacilityError(facStatusList);
        //    });

        //}

        //#endregion

        //#region 設備走行停止
        ///// <summary>
        ///// 設備ステータスリストより、走行停止装置の停止ステータスを確認
        ///// 停止装置がONであり、関連異常が発生されていない場合、異常処理を行う
        ///// </summary>
        ///// <param name="facStatusList">設備ステータスリスト</param>
        //private void CheckStopBtnError(List<FacilityStatus> facStatusList)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        // ステータス = "ON"の走行停止装置取得
        //        List<FacilityStatus> erroredstopBtnList = facStatusList
        //            .Where(fac => fac.FacilityTypeID == (int)FacilityTypes.StopBtn)
        //            .Where(stopBtn => stopBtn.Status1 == 1)
        //            .ToList();

        //        foreach (FacilityStatus erroredBtn in erroredstopBtnList)
        //        {
        //            GetGroupIDListFromMemberID(GROUP_MEMBER.IO_FACILITY, erroredBtn.FacilityID)
        //                .ForEach(groupID =>
        //                {
        //                    bool isAlreadyErrored = m_dicErrorInfos.ContainsKey(groupID);

        //                    if (isAlreadyErrored)
        //                    {
        //                        // グループが既に異常の場合スキップ
        //                        return;
        //                    }

        //                    string errTarCtrlUnitID = GetCtrlIDFromGroupID(groupID);

        //                    if (errTarCtrlUnitID == null)
        //                    {
        //                        // 対象制御端末を取得できない場合スキップ
        //                        return;
        //                    }

        //                    CtrlUnitState unit = m_ctrlUnitStates
        //                        .SingleOrDefault(ctrl => ctrl.CtrlUnit.ID == errTarCtrlUnitID);

        //                    if (unit == null || !unit.IsRunning())
        //                    {
        //                        // 対象制御端末が制御中でない場合、スキップ
        //                        return;
        //                    }

        //                    LOGGER.Info($"[走行停止] 走行停止装置ステータスがONのため、走行停止処理を行います。");
        //                    LOGGER.Info($"    設備ID: {erroredBtn.FacilityID}, 設備名称: {erroredBtn.FacilityName}, 対象グループID: {groupID}");

        //                    string explicitMsg = ErrorStatusGetMsg(Res.ErrorStatus.FACILITY_ERR_DETECT.Code) + $"({erroredBtn.FacilityID}, {erroredBtn.FacilityName})";
        //                    ErrorPreProcess(unit, Res.ErrorStatus.FACILITY_ERR_DETECT.Code, ErroredFrom.Fac, explicitMsg);
        //                });
        //        }

        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 設備ステータスリストより、エリアセンサの一時停止ステータスを確認
        ///// エリアセンサがONであり、対象制御グループが一時停止でない場合、一時停止処理を行う
        ///// </summary>
        ///// <param name="facStatusList">設備ステータスリスト</param>
        //private void CheckAreaSensorPause(List<FacilityStatus> facStatusList)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        foreach (Group group in m_groups)
        //        {
        //            List<string> facilities = GetErrorSetFacilityIDs(group.ID);
        //            List<FacilityStatus> detectedAreaSensors = facStatusList
        //                                    .Where(f => facilities.Contains(f.FacilityID))
        //                                    .Where(f => f.FacilityTypeID == (int)FacilityTypes.AreaSensor)
        //                                    .Where(areaSensor => areaSensor.Status1 == 1)
        //                                    .ToList();

        //            if (detectedAreaSensors.Count > 0)
        //            {
        //                string targetCtrl = GetCtrlIDFromGroupID(group.ID);

        //                if (targetCtrl == null)
        //                {
        //                    // 対象制御グループ内に経路生成部がない場合、スキップ
        //                    continue;
        //                }

        //                CtrlUnitState unitStatus = m_ctrlUnitStates.SingleOrDefault(unit => unit.CtrlUnit.ID == targetCtrl);

        //                if (unitStatus == null || !unitStatus.IsRunning() || !unitStatus.IsOnCtrl())
        //                {
        //                    // 対象経路生成部が取得できない、または、制御中でない場合、スキップ
        //                    continue;
        //                }

        //                if (unitStatus.Status.In(Res.CtrlStatus.PAUSED, Res.CtrlStatus.PAUSING))
        //                {
        //                    // 対象経路生成部が既に一時停止中・一時停止である場合、スキップ
        //                    continue;
        //                }

        //                string sensorList = detectedAreaSensors
        //                    .Select(sensor => $"{sensor.FacilityID} {sensor.FacilityName}")
        //                    .Aggregate((curr, next) => curr + ", " + next);

        //                LOGGER.Warn($"[一時停止] エリアセンサ検出: {sensorList}");

        //                CtrlPauseSndMsg pauseMsg = new CtrlPauseSndMsg();

        //                m_ctrlTcpController.SendMessage(unitStatus.ConnectionID, pauseMsg);

        //                if (m_dicCarStatus.Keys.Contains(unitStatus.CarNo))
        //                {
        //                    CarStatus carStat = m_dicCarStatus[unitStatus.CarNo];

        //                    lock (carStat)
        //                    {
        //                        carStat.Pause();
        //                    }
        //                }
        //            }
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 設備ステータスリストより、エリアセンサの一時停止ステータスを確認
        ///// エリアセンサがOFFであり、対象制御グループが一時停止である場合、一時停止解除処理を行う
        ///// </summary>
        ///// <param name="facStatusList">設備ステータスリスト</param>
        //private void CheckAreaSensorPauseCancel(List<FacilityStatus> facStatusList)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        foreach (Group group in m_groups)
        //        {
        //            List<string> facilities = GetErrorSetFacilityIDs(group.ID);
        //            bool allSensorResolved = facStatusList
        //                                    .Where(f => facilities.Contains(f.FacilityID))
        //                                    .Where(f => f.FacilityTypeID == (int)FacilityTypes.AreaSensor)
        //                                    .All(areaSensor => areaSensor.Status1 == 0);

        //            if (allSensorResolved)
        //            {
        //                string targetCtrl = GetCtrlIDFromGroupID(group.ID);

        //                if (targetCtrl == null)
        //                {
        //                    // 対象制御グループ内に経路生成部がない場合、スキップ
        //                    continue;
        //                }

        //                CtrlUnitState unitStatus = m_ctrlUnitStates.SingleOrDefault(unit => unit.CtrlUnit.ID == targetCtrl);

        //                if (unitStatus == null)
        //                {
        //                    // 対象経路生成部が取得できない場合、スキップ
        //                    continue;
        //                }

        //                if (unitStatus.Status.In(Res.CtrlStatus.PAUSED, Res.CtrlStatus.PAUSING))
        //                {
        //                    CtrlPauseCancelSndMsg pauseCancelMsg = new CtrlPauseCancelSndMsg();

        //                    m_ctrlTcpController.SendMessage(unitStatus.ConnectionID, pauseCancelMsg);

        //                    if (m_dicCarStatus.Keys.Contains(unitStatus.CarNo))
        //                    {
        //                        CarStatus carStat = m_dicCarStatus[unitStatus.CarNo];

        //                        lock (carStat)
        //                        {
        //                            carStat.Resume();
        //                        }
        //                    }
        //                }
        //                else
        //                {
        //                    continue;
        //                }
        //            }
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 設備ステータスリストより、全設備のステータスを確認
        ///// ステータスがエラーのものがある場合、走行停止タイマーを開始する
        ///// </summary>
        ///// <param name="facStatusList">設備ステータスリスト</param>
        //private void CheckDIOFacilityError(List<FacilityStatus> facStatusList)
        //{
        //    try
        //    {
        //        LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        bool err = false;

        //        // ステータス = "エラー"の設備
        //        List<FacilityStatus> erroredfacilityList = facStatusList
        //            //.Where(fac => fac.FacilityTypeID == (int)FacilityTypes.StopBtn)
        //            .Where(stopBtn => stopBtn.Status1 == -1)
        //            .ToList();

        //        foreach (FacilityStatus erroredfacility in erroredfacilityList)
        //        {
        //            GetGroupIDListFromMemberID(GROUP_MEMBER.IO_FACILITY, erroredfacility.FacilityID)
        //                .ForEach(groupID =>
        //                {
        //                    bool isAlreadyErrored = m_dicErrorInfos.ContainsKey(groupID);

        //                    if (isAlreadyErrored)
        //                    {
        //                        // グループが既に異常の場合スキップ
        //                        return;
        //                    }

        //                    string errTarCtrlUnitID = GetCtrlIDFromGroupID(groupID);

        //                    if (errTarCtrlUnitID == null)
        //                    {
        //                        // 対象制御端末を取得できない場合スキップ
        //                        return;
        //                    }

        //                    CtrlUnitState unit = m_ctrlUnitStates
        //                        .SingleOrDefault(ctrl => ctrl.CtrlUnit.ID == errTarCtrlUnitID);

        //                    if (unit == null || !unit.IsRunning())
        //                    {
        //                        // 対象制御端末が制御中でない場合、スキップ
        //                        return;
        //                    }

        //                    err = true;
        //                    if (m_err_timer == null)
        //                    {
        //                        m_err_timer = new System.Threading.Timer(new TimerCallback(Callback_DIOfacility_Err), erroredfacilityList, m_FACILITY_STATUS_FAIL_TIMEOUT, 0);
        //                        LOGGER.Info($"[走行停止] 設備ステータス取得不可のため、タイマーを開始します。");
        //                        LOGGER.Info($"    設備ID: {erroredfacility.FacilityID}, 設備名称: {erroredfacility.FacilityName}, 対象グループID: {groupID}");
        //                    }
        //                });
        //        }

        //        if (m_err_timer != null && err == false)
        //        {
        //            m_err_timer.Dispose();
        //            m_err_timer = null;
        //            LOGGER.Info($"[走行停止] 設備ステータス取得したため、タイマーを停止します。");
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        //#endregion

        //#region ## 残留検知処理 ##

        ///// <summary>
        ///// 設備ステータス情報からGoalNoを更新する。
        ///// GoalNoが変更されたとき、制御端末にゴールエリア変更通知を送信する。
        ///// </summary>
        ///// <param name="facilityStatus">すべての設備ステータスのリスト</param>
        //private void UpdateGoalAreaNo(List<FacilityStatus> facilityStatus)
        //{
        //    List<FacilityStatus> remainFacStatusList = new List<FacilityStatus>();
        //    List<string> remainDetectFacilityIDList = m_goalAreas.Select(area => area.FacilityID).ToList();

        //    foreach (string facId in remainDetectFacilityIDList)
        //    {
        //        FacilityStatus remainDetectFac = facilityStatus.Single(fac => fac.FacilityID == facId);
        //        remainFacStatusList.Add(remainDetectFac);
        //    }

        //    foreach (CtrlUnitState unit in m_ctrlUnitStates)
        //    {
        //        int newGoalNo = GetNewCtrlGoalArea(remainFacStatusList, unit.CtrlUnit.ID);
        //        unit.SetGoalNo(newGoalNo);
        //    }
        //}

        ///// <summary>
        ///// 制御端末のゴールエリアを取得する
        ///// </summary>
        ///// <param name="remainFacStatusList">残留検知の設備ステータスリスト</param>
        ///// <param name="unitId">確認中の制御端末</param>
        ///// <returns>制御端末のゴールエリアNo</returns>
        //private int GetNewCtrlGoalArea(List<FacilityStatus> remainFacStatusList, string unitId)
        //{
        //    // 制御端末ごとの残留検知設備ID
        //    List<string> facIds = m_goalAreas
        //        .Where(goal => goal.CtrlUnitID == unitId)
        //        .Select(goal => goal.FacilityID)
        //        .ToList();

        //    // 設定情報がない場合、デフォルトゴールエリアを返却
        //    if (facIds.Count <= 0)
        //    {
        //        return m_DEFAULT_GOAL_AREA;
        //    }

        //    // 残留検知された設備
        //    List<FacilityStatus> remainingFac = remainFacStatusList
        //        .Where(fac => facIds.Contains(fac.FacilityID))
        //        .Where(fac => fac.Status1 == 1)
        //        .ToList();

        //    // 検知された設備の設備ID
        //    List<string> remainingId = remainingFac
        //        .Select(fac => fac.FacilityID).ToList();

        //    if (remainingFac.Count == 0)
        //    {
        //        LOGGER.Debug($"[ゴールエリア取得] 残留なし制御端末 → 最小ゴールエリアNoに設定。{Res.C_CTRL_UNIT}ID: {unitId}");
        //        int minGoalNo = m_goalAreas
        //            .Where(goal => goal.CtrlUnitID == unitId)
        //            .Min(goal => goal.GoalNo) ?? m_DEFAULT_GOAL_AREA;
        //        return minGoalNo;
        //    }

        //    //最大ゴールNo( Status == 1 )取得
        //    int maxRemainGoalNo = m_goalAreas
        //        .Where(goal => remainingId.Contains(goal.FacilityID))
        //        .Where(goal => goal.CtrlUnitID == unitId)
        //        .Max(goal => goal.GoalNo) ?? m_DEFAULT_GOAL_AREA;

        //    //m_goalAreasの最後のGoalNo
        //    int lastGoalAreas = m_goalAreas
        //        .Where(goal => goal.CtrlUnitID == unitId)
        //        .Max(goal => goal.GoalNo) ?? m_DEFAULT_GOAL_AREA;

        //    if (maxRemainGoalNo == lastGoalAreas)
        //    {
        //        return maxRemainGoalNo + 1;
        //    }

        //    //最大残留検知GoalNoより大きい中の最小GoalNo
        //    int minAvailableGoalNo = m_goalAreas
        //        .Where(goal => goal.CtrlUnitID == unitId)
        //        .Where(goal => goal.GoalNo > maxRemainGoalNo)
        //        .Min(goal => goal.GoalNo) ?? m_DEFAULT_GOAL_AREA;

        //    return minAvailableGoalNo;
        //}

        //#endregion

        //#region ## 設備制御処理 ##

        ///// <summary>
        ///// 設備ステータスを要求指示ステータスに変更<para/>
        ///// 変更完了後、指示受信Tcpサーバーより完了電文を返信
        ///// </summary>
        ///// <param name="facilityID">対象設備ID</param>
        ///// <param name="reqStatus">要求ステータス</param>
        ///// <param name="rcvSrv">指示受信Tcpサーバー</param>
        ///// <param name="connID">接続ID</param>
        //internal void SetFacilityRequestedStatus(string facilityID, int reqStatus, CommSrv rcvSrv, int connID, string clientName)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        // 設備ID 存在チェック
        //        if (!m_dicFacilityStatus.Keys.Contains(facilityID))
        //        {
        //            LOGGER.Warn($"[設備制御不可] 存在しない設備IDが制御指示されました。[設備ID: {facilityID}]");
        //            return;
        //        }

        //        FacilityControl currentControl = new FacilityControl(rcvSrv, connID, facilityID, reqStatus, clientName);

        //        // 設備制御中チェック
        //        FacilityControl control = null;
        //        lock (m_facilityControlThreads)
        //        {
        //            control = m_facilityControlThreads
        //                .SingleOrDefault(c => c.FacilityID == facilityID && c.CtrlValue == reqStatus);
        //        }

        //        if (control != null)
        //        {
        //            if (control.m_reset != null)
        //            {
        //                lock (control.m_reset)
        //                {
        //                    control.m_reset.Set();
        //                }

        //            }
        //            LOGGER.Warn($"既 制御中の設備制御 受信: 設備ID: {facilityID}, 制御指定値: {reqStatus}");
        //        }


        //        // 設備制御実施
        //        LOGGER.Info($"設備制御開始　　: 設備ID: {facilityID}, 制御指定値: {reqStatus}");

        //        lock (m_facilityControlThreads)
        //        {
        //            m_facilityControlThreads.Add(currentControl);
        //        }

        //        int facilityTypeID = m_dicFacilityStatus[facilityID].FacilityTypeID;

        //        int result = ControlSetFacility(facilityID, facilityTypeID, reqStatus, true);

        //        bool ctrlDone = false;
        //        switch (result)
        //        {
        //            case DIO_CONTROL_RESULT.C_FACILITY_CTRL_ERROR:
        //                LOGGER.Error($"設備制御失敗　　: 設備ID: {facilityID}, 制御指定値: {reqStatus}");

        //                GetCtrlIDListFromFacilityID(facilityID)
        //                .ForEach((unitID) =>
        //                {
        //                    CtrlUnitState ctrlUnit = m_ctrlUnitStates.SingleOrDefault(unit => unit.CtrlUnit.ID == unitID);
        //                    if (ctrlUnit != null && ctrlUnit.IsRunning())
        //                    {
        //                        LOGGER.Info($"[走行停止] 設備制御失敗のため、対象経路生成部の走行停止処理を行います。{Res.C_CTRL_UNIT}ID:{unitID}");
        //                        ErrorPreProcess(ctrlUnit, Res.ErrorStatus.FACILITY_ERR.Code, ErroredFrom.Mng, GetFacilityCtrlFailMsg(facilityID, reqStatus));
        //                    }
        //                });
        //                break;
        //            case DIO_CONTROL_RESULT.C_FACILITY_CTRL_INTERRUPTED:
        //                // TODO: 他の設備制御指示発生
        //                LOGGER.Warn($"設備制御取消　　: 設備ID: {facilityID}, 制御指定値: {reqStatus}");
        //                break;
        //            case DIO_CONTROL_RESULT.C_FACILITY_CTRL_NORMAL_END:
        //                ctrlDone = CheckFacCtrlDone(currentControl, facilityID, reqStatus);
        //                break;
        //            default:
        //                break;
        //        }

        //        // 設備制御完了処理
        //        if (ctrlDone)
        //        {
        //            LOGGER.Info($"設備制御正常終了: 設備ID: {facilityID}, 制御指定値: {reqStatus}");
        //            List<FacilityControl> targetToSendDone = m_facControlWaits
        //                        .Where(wait => wait.FacilityID == facilityID && wait.CtrlValue == reqStatus)
        //                        .ToList();
        //            bool alreadyListed = targetToSendDone.SingleOrDefault(wait => wait.Equals(currentControl)) != null;
        //            if (!alreadyListed)
        //            {
        //                targetToSendDone.Add(currentControl);
        //            }

        //            foreach (FacilityControl toSend in targetToSendDone)
        //            {
        //                SendFacCtrlNormalEndMsg(toSend);
        //                m_facControlWaits.Remove(toSend);
        //            }
        //        }
        //        else
        //        {
        //            // 設備が指示値に変更できず、確認処理終了
        //            bool alreadyWaiting = m_facControlWaits.SingleOrDefault(wait => wait.Equals(currentControl)) != null;
        //            if (!alreadyWaiting)
        //            {
        //                m_facControlWaits.Add(currentControl);
        //            }
        //        }

        //        lock (currentControl.m_reset)
        //        {
        //            currentControl.m_reset.Dispose();
        //        }

        //        lock (m_facilityControlThreads)
        //        {
        //            m_facilityControlThreads.Remove(currentControl);
        //        }

        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 設備IDで指定された設備を種別、指示値に合わせて制御する。
        ///// </summary>
        ///// <param name="facilityID">設備ID</param>
        ///// <param name="facilityTypeID">設備種別</param>
        ///// <param name="ctrlValue">指示値</param>
        ///// <param name="forceCtrl">強制制御フラグ</param>
        ///// <returns>制御結果</returns>
        ///// <see cref="DIO_CONTROL_RESULT"/>
        //private int ControlSetFacility(string facilityID, int facilityTypeID, int ctrlValue, bool forceCtrl)
        //{
        //    // 3灯信号機: 赤、2灯信号機: 赤 の場合、別処理
        //    if (facilityTypeID == 0 && ctrlValue == 1) // 3灯信号機 赤
        //    {
        //        // 黄色 → 赤
        //        List<FacCtrlStep> steps = new List<FacCtrlStep>() { FacCtrlStep.OneShot(2), FacCtrlStep.OneShot(1) };
        //        int interval = GetFaciliyIntervalConfig();
        //        if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.ContecDIO)
        //        {
        //            return m_DIOControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, interval);
        //        }
        //        else if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.PLC)
        //        {
        //            return m_PLCControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, interval);
        //        }
        //        else { return 2; }
        //    }
        //    else if (facilityTypeID == 1 && ctrlValue == 1) // 2灯信号機 赤
        //    {
        //        int interval = GetFaciliyIntervalConfig();
        //        int repeatInterval = GetFaciliyRepeatIntervalConfig();
        //        // 青点滅(青→消灯: 繰り返し) → 赤
        //        List<FacCtrlStep> steps = new List<FacCtrlStep>() { FacCtrlStep.Repeat(new int[] { 0, 3 }, repeatInterval), FacCtrlStep.OneShot(1) };
        //        if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.ContecDIO)
        //        {
        //            return m_DIOControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, interval);
        //        }
        //        else if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.PLC)
        //        {
        //            return m_PLCControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, interval);
        //        }
        //        else { return 2; }
        //    }
        //    else // 一般制御
        //    {
        //        List<FacCtrlStep> steps = new List<FacCtrlStep>() { FacCtrlStep.OneShot(ctrlValue) };
        //        if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.ContecDIO)
        //        {
        //            return m_DIOControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, 0);
        //        }
        //        else if (m_FACILITY_CONTROL_MODE == (int)FACILITY_CONTROL_MODE.PLC)
        //        {
        //            return m_PLCControl.FacCtrlStepSet(facilityID, facilityTypeID, steps, forceCtrl, 0);
        //        }
        //        else { return 2; }
        //    }
        //}

        ///// <summary>
        ///// 設備IDで指定された設備が指示値になるまで繰り返し確認する。
        ///// </summary>
        ///// <returns>設備が指示値に変更された場合True、
        ///// 指示値に変更される前に繰り返し確認がキャンセルされた場合False</returns>
        ///// </summary>
        //private bool CheckFacCtrlDone(FacilityControl targetControl, string facilityID, int ctrlValue)
        //{
        //    do
        //    {
        //        if (m_dicFacilityStatus[facilityID].Status1 == ctrlValue)
        //        {
        //            return true;
        //        }
        //    }
        //    while (!targetControl.m_reset.WaitOne(m_STATUS_UPDATE_INTERVAL));

        //    return false;
        //}

        ///// <summary>
        ///// 異常時、ステータスを変更する設備IDリストを取得
        ///// </summary>
        ///// <param name="ctrlUnitId">制御端末ID</param>
        ///// <returns>異常処理対象制御端末と同じグループに属している設備のIDリスト</returns>
        //internal List<string> GetErrorSetFacilityIDs(string groupID)
        //{
        //    // 制御端末と同じグループに属している設備のIDリストを取得
        //    List<string> errSetTargetFacilityies = m_groupMembers
        //        .Where(gMember => gMember.GroupID == groupID)
        //        .Where(gMember => gMember.MemberType == GROUP_MEMBER.IO_FACILITY.Code)
        //        .Select(gMember => gMember.MemberID)
        //        .ToList();

        //    return errSetTargetFacilityies;
        //}

        ///// <summary>
        ///// 対象設備の異常時設定ステータス値を取得
        ///// </summary>
        ///// <param name="facilityIDs">対象設備IDリスト</param>
        ///// <returns>対象設備情報と異常時設定ステータス値</returns>
        //private Dictionary<FacilityStatus, int> GetFacilityErrorSetValues(List<string> facilityIDs)
        //{
        //    Dictionary<FacilityStatus, int> facilityErrorSetValues = new Dictionary<FacilityStatus, int>();

        //    foreach (string facilityID in facilityIDs)
        //    {
        //        FacilityStatus fac = m_dicFacilityStatus[facilityID];
        //        if (fac == null)
        //        {
        //            LOGGER.Warn($"[異常時設定値 取得不可] 指定されたIO設備が存在しません。設備ID: {facilityID}");
        //            continue;
        //        }
        //        FacilityType facType = m_facilityTypes.SingleOrDefault(typeInfo => typeInfo.ID == fac.FacilityTypeID);
        //        if (facType == null)
        //        {
        //            LOGGER.Warn($"[異常時設定値 取得不可] 指定されたIO設備の種別を判定できません。設備ID: {facilityID}, 設備種別ID: {fac.FacilityTypeID}");
        //            continue;
        //        }
        //        int? ErrorStatus = facType.ErrorStatus;
        //        if (ErrorStatus != null)
        //        {
        //            facilityErrorSetValues.Add(fac, (int)ErrorStatus);
        //        }
        //    }
        //    return facilityErrorSetValues;
        //}

        ///// <summary>
        ///// 対象設備の異常解除時設定ステータス値を取得
        ///// </summary>
        ///// <param name="facilityIDs">対象設備IDリスト</param>
        ///// <returns>対象設備情報と異常解除時設定ステータス値</returns>
        //internal Dictionary<FacilityStatus, int> GetFacilityErrorResolveValues(List<string> facilityIDs)
        //{
        //    Dictionary<FacilityStatus, int> facilityErrorResolveValues = new Dictionary<FacilityStatus, int>();

        //    foreach (string facilityID in facilityIDs)
        //    {
        //        FacilityStatus fac = m_dicFacilityStatus[facilityID];
        //        if (fac == null)
        //        {
        //            LOGGER.Warn($"[異常解除] グループメンバーIO設備が存在しません。設備ID: {facilityID}");
        //            continue;
        //        }
        //        FacilityType facType = m_facilityTypes.SingleOrDefault(typeInfo => typeInfo.ID == fac.FacilityTypeID);
        //        int? resolveStatus = facType.ResolveStatus;
        //        if (resolveStatus != null)
        //        {
        //            facilityErrorResolveValues.Add(fac, (int)resolveStatus);
        //        }
        //    }
        //    return facilityErrorResolveValues;
        //}

        ///// <summary>
        ///// 並行設備制御
        ///// </summary>
        ///// <param name="controlList">制御指示リスト</param>
        ///// <returns>制御結果リスト(設備ID、制御処理結果)</returns>
        //internal Dictionary<string, int> ParallelFacilityControl(Dictionary<FacilityStatus, int> controlList)
        //{
        //    Dictionary<string, int> ctrlResults = new Dictionary<string, int>();

        //    for (int i = 0; i < controlList.Count; i++)
        //    {
        //        try
        //        {
        //            FacilityStatus facility = controlList.ElementAt(i).Key;
        //            int ctrlValue = controlList.ElementAt(i).Value;

        //            LOGGER.Info($"[設備ステータスを変更] 設備ID: {facility.FacilityID}, 設備名: {facility.FacilityName}, 設定値: {ctrlValue}");
        //            int ctrlRes = ControlSetFacility(facility.FacilityID, facility.FacilityTypeID, ctrlValue, true);
        //            ctrlResults.Add(facility.FacilityID, ctrlRes);
        //        }
        //        catch (Exception ex)
        //        {
        //            ExceptionProcess.ComnExceptionConsoleProcess(ex);
        //            FacilityStatus facility = controlList.ElementAt(i).Key;
        //            ctrlResults.Add(facility.FacilityID, DIO_CONTROL_RESULT.C_FACILITY_CTRL_ERROR);
        //        }
        //    }

        //    return ctrlResults;
        //}

        ///// <summary>
        ///// 設備制御失敗メッセージ作成
        ///// </summary>
        ///// <param name="FacilityID">対象設備ID</param>
        ///// <param name="FailedCtrlVal">制御失敗指示値</param>
        ///// <returns>設備制御失敗エラーメッセージ</returns>
        //internal string GetFacilityCtrlFailMsg(string FacilityID, int FailedCtrlVal)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        FacilityStatus erroredFacility = m_dicFacilityStatus.Values.SingleOrDefault(f => f.FacilityID == FacilityID);
        //        string facilityName = "";
        //        string ctrlValName = "";
        //        if (erroredFacility == null)
        //        {
        //            LOGGER.Warn($"[メッセージ作成失敗] 該当する設備情報が見つけれません。" +
        //                $"異常内容はID、指示値で表示されます。設備ID:{FacilityID}, 制御値:{FailedCtrlVal}");
        //            facilityName = $"設備ID:{FacilityID}";
        //            ctrlValName = $"制御値:{FailedCtrlVal}";
        //        }
        //        else
        //        {
        //            facilityName = erroredFacility.FacilityName;

        //            FacilityStatusMsg statMsg = m_facilityStatusMsgs
        //                    .Where(fStatus => fStatus.FacilityTypeID == erroredFacility.FacilityTypeID)
        //                    .Where(fStatus => fStatus.StatusCode == FailedCtrlVal)
        //                    .SingleOrDefault();
        //            ctrlValName = statMsg == null ? $"制御値:{FailedCtrlVal}" : statMsg.StatusMsg;
        //        }

        //        return string.Format(ErrorStatusGetMsg(Res.ErrorStatus.FACILITY_ERR.Code), facilityName, ctrlValName);
        //    }
        //    finally
        //    {
        //        LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //    }
        //}

        ///// <summary>
        ///// 設備制御指示の正常終了応答送信
        ///// </summary>
        ///// <param name="connID">指示受信接続ID</param>
        ///// <param name="facilityID">制御設備ID</param>
        ///// <param name="ctrlValue">制御指示値</param>
        //private void SendFacCtrlNormalEndMsg(FacilityControl facCtrlInfo)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        FacStatusResSndMsg facStatusResMsg = new FacStatusResSndMsg()
        //        {
        //            facID = facCtrlInfo.FacilityID
        //        };

        //        facCtrlInfo.ReceivedServer.SendMessage(facCtrlInfo.ConnectionID, facStatusResMsg);
        //        LOGGER.Info(GetMsgSndLog(facCtrlInfo.ClientName, facStatusResMsg));
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 設備シーケンス制御時間間隔取得
        ///// </summary>
        //private int GetFaciliyIntervalConfig()
        //{
        //    string strInterval = ConfigurationManager.AppSettings["FACILITY_CTRL_INTERVAL"];
        //    int interval = 2000;
        //    bool isValidConfig = int.TryParse(strInterval, out interval);
        //    if (!isValidConfig)
        //    {
        //        throw new UserException($"設定値 FACILITY_CTRL_INTERVAL: {strInterval}を整数に変更できませんでした。");
        //    }
        //    return interval;
        //}

        ///// <summary>
        ///// 設備繰り返し制御時間間隔取得
        ///// </summary>
        //private int GetFaciliyRepeatIntervalConfig()
        //{
        //    string strInterval = ConfigurationManager.AppSettings["FACILITY_CTRL_REPEAT_INTERVAL"];
        //    int interval = 300;
        //    bool isValidConfig = int.TryParse(strInterval, out interval);
        //    if (!isValidConfig)
        //    {
        //        throw new UserException($"設定値 FACILITY_CTRL_REPEAT_INTERVAL: {strInterval}を整数に変更できませんでした。");
        //    }
        //    return interval;
        //}

        ///// <summary>
        ///// 管制モードに合うように対象設備を更新制御
        ///// </summary>
        ///// <param name="facStatusList">現在設備ステータスリスト</param>
        //private void UpdateManagerModeFacility(List<FacilityStatus> facStatusList)
        //{
        //    LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        LOGGER.Debug($"管制モード表示設備更新");

        //        Dictionary<FacilityStatus, int> unmatchingFacilities =
        //            facStatusList
        //            .Where(f => f.FacilityTypeID == (int)FacilityTypes.MngModeViewer)
        //            .Where(f => f.Status1 != (int)Mode)
        //            .ToDictionary(f => f, f => (int)Mode);

        //        if (unmatchingFacilities.Count <= 0)
        //        {
        //            LOGGER.Debug($"設備ステータスが管制モードに一致するため処理スキップ");
        //            return;
        //        }
        //        else
        //        {
        //            ParallelFacilityControl(unmatchingFacilities);
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionConsoleProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { LOGGER.Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        #endregion

        #endregion

        #region 待機中への戻し
        /// <summary>
        /// 待機中への戻し
        /// </summary>
        public void WaitControlEndResetStatus()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            if (m_EmergencyStop == false)
            {
                LOGGER.Info($"ステータスを待機中に変更します：{m_CarControlStatus}=>{OperationConst.ControlStatusType.C_NOT_IN_CONTROL}");
            }
            m_CarControlStatus = OperationConst.ControlStatusType.C_NOT_IN_CONTROL;

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        #endregion

        #region 制御開始処理
        //private void ControlStartProc()
        public void ControlStartProc()
        {
            //※ 削除対象(DBやRFIDから取得)
            ControlStartClass controlStart = new ControlStartClass();
            ReadFile("xml/ControlStart.xml", ref controlStart);
            string CarNo = controlStart.CarNo;
            string CarSpecNo = controlStart.CarSpecNo;
            string IPaddr = controlStart.IPaddr;
            int GoalNo = controlStart.GoalNo;
            string GearRate = controlStart.GearRate;
            string Wheelbase = controlStart.Wheelbase;
            string WidthDistance = controlStart.WidthDistance;
            string ForwardDistance = controlStart.ForwardDistance;
            string AreaAdjust = controlStart.AreaAdjust;
            int PORT1 = controlStart.PORT1;
            double CenterFrontLength = controlStart.CenterFrontLength;
            double CenterEndLength = controlStart.CenterEndLength;

            m_camList = new List<CamList>();
            ReadFile("xml/Camlist.xml", ref m_camList);
            //※

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");
            try
            {
                m_CarNo = CarNo;
                m_CarSpec = CarSpecNo;
                string IP = IPaddr;

                //開始前ステータスチェック
                string code = StartStatusCheck();
                if (code != Res.ErrorStatus.NORMAL.Code)
                {
                    if (code == Res.ErrorStatus.B_ERR.Code)
                    {
                        ControlStartStatus(code, GetCamRcvInfo(MainC).CamID);
                    }
                    else
                    {
                        ControlStartStatus(code);
                    }
                    return;
                }

                //値の初期化
                ResetVal();

                //ゴール番号更新
                m_ConfigData.GoalNo = GoalNo;
                foreach (OtherAreaRetention otherArea in m_otherArea)
                {
                    if (otherArea.otherarea.AreaCode == OtherAreaCode.GoalArea && m_ConfigData.GoalNo == otherArea.otherarea.Number)
                    {
                        m_controlCenterData.goalarea = otherArea.otherarea.area[OperationConst.FacilityAreaStage.C_FACILITY_START];
                    }
                }

                //ギア比更新
                if (double.Parse(GearRate) != 0)
                {
                    m_ConfigData.GearRate = double.Parse(GearRate);
                }
                //ホイールベース更新
                if (double.Parse(Wheelbase) != 0)
                {
                    m_ConfigData.Wheelbase = double.Parse(Wheelbase);
                }
                //車両全幅
                if (double.Parse(WidthDistance) != 0)
                {
                    m_ConfigData.WidthDistance = double.Parse(WidthDistance);
                }
                //前方注視距離
                if (double.Parse(ForwardDistance) != 0)
                {
                    m_ConfigData.ForwardDistance = double.Parse(ForwardDistance);
                }
                //車両仕様反映
                m_carSpec = new AtrptShare.CarSpec()
                {
                    GearRate = double.Parse(GearRate) != 0 ? double.Parse(GearRate) : m_ConfigData.GearRate,
                    Wheelbase = double.Parse(Wheelbase) != 0 ? double.Parse(Wheelbase) : m_ConfigData.Wheelbase,
                    ForwardDistance = m_ConfigData.ForwardDistance,
                    WidthDistance = m_ConfigData.WidthDistance,
                    CenterFrontLength = CenterFrontLength,
                    CenterEndLength = CenterEndLength
                };

                //走行エリア調整 
                //foreach (CourseInfo course in m_CourseInfoList)
                //{
                //    SpeedAreaReset(course);
                //}
                SpeedAreaAdjust(double.Parse(AreaAdjust));

                m_TerminalStatus = Res.CtrlStatus.ON_CTRL.Code;

                //制御開始時時刻取得
                m_now = DateTime.Now;

                //制御指示送信後タイマー開始
                m_timer_ci = new System.Threading.Timer(new TimerCallback(Callback_CarStatus), null, Timeout.Infinite, 0);
                m_ci_interval = OperationConst.C_CI_FIRST_INTERVAL;
                m_timer_ci.Change(0, m_ci_interval);

                //画像解析測位開始            
                ExeCamControlStart(MainC,m_CarNo, m_now);

                //車両制御開始
                CarControlStart(IP, CarSpecNo, PORT1);

                //計算部起動
                SettingInfo settingInfo = new SettingInfo();
                PanaSettingData panaSettingData = SetPanaSettingData();
                settingInfo.vehicle_type_id = stringToChar(m_CarSpec);
                panaSettingData.carSpec = m_carSpec;
                LOGGER.Debug($"before[settingInfo.vehicle_type_id:{charToString(settingInfo.vehicle_type_id)}");
                LOGGER.Debug($"before[ConnectVal.mClConnectIP:{m_ConfigData.ConnectVal.mClConnectIP.ToString()},CalcCoefficient.Kp.ToString:{m_ConfigData.CalcCoefficient.Kp.ToString()},ForwardDistance:{m_ConfigData.ForwardDistance.ToString()},WidthDistance:{m_ConfigData.WidthDistance.ToString()},FFGetStartPosition:{m_ConfigData.FFGetStartPosition.ToString()},LimitVal.AngleLimit:{m_ConfigData.LimitVal.AngleLimit.ToString()},GlobalCoordinate.maxCoordinate:{m_ConfigData.GlobalCoordinate.maxCoordinate.ToString()},Acceleration.DeceAmount:{m_ConfigData.Acceleration.DeceAmount.ToString()},GetCondition.GetRadian:{m_ConfigData.GetCondition.GetRadian.ToString()},OtherAreas数:{m_ConfigData.OtherAreas.Count.ToString()},GoalNo:{m_ConfigData.GoalNo.ToString()},GearRate:{m_ConfigData.GearRate.ToString()},Wheelbase:{m_ConfigData.Wheelbase.ToString()},trafficLights:{m_ConfigData.trafficLights.Any().ToString()},シャッター:{m_ConfigData.shutters.Any().ToString()},facilitys:{m_ConfigData.facilitys.Any().ToString()},camscore:{m_ConfigData.camscore},fixcnt:{m_ConfigData.fixcnt},nofixcam:{m_ConfigData.nofixcam},");
                LOGGER.Debug($"before[actual_angle_wait:{panaSettingData.constData.actual_angle_wait},use_start_yawrate:{panaSettingData.constData.use_start_yawrate},start_yawrate:{panaSettingData.constData.start_yawrate},first_pos_x:{panaSettingData.constData.first_pos_x},first_pos_y:{panaSettingData.constData.first_pos_y},first_diff_x:{panaSettingData.constData.first_diff_x},first_diff_y:{panaSettingData.constData.first_diff_y},first_errmax_cnt:{panaSettingData.constData.first_errmax_cnt},score_all_use:{panaSettingData.constData.score_all_use},angle_limit_mode:{panaSettingData.constData.angle_limit_mode},acceleration_mode:{panaSettingData.constData.acceleration_mode},include_judge_area_count:{panaSettingData.constData.include_judge_area_count},first_vector:{panaSettingData.first_vector}");

                try
                {
                    m_calc = new clsCalculator(settingInfo, (ConfigData)m_ConfigData.Clone(), (PanaSettingData)panaSettingData.Clone());
                }
                catch (Exception e)
                {
                    LOGGER.Error(e.Message);
                    ControlStartStatus(Res.ErrorStatus.R_ERR.Code);
                    return;
                }

                //加速度舵角通知タイマー開始
                m_timer_cc = new System.Threading.Timer(new TimerCallback(Callback_Kasoku), null, Timeout.Infinite, 0);
                m_timer_cc.Change(0, C_CC_CALC_WAITTIME);

                
            }
            catch (UserException ex)
            {
                LOGGER.Error(ex.Message);

            }
            catch (Exception e)
            {
                LOGGER.Error(e.Message);
                ControlStartStatus(Res.ErrorStatus.N_ERR.Code);
            }
            finally
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
            }
        }

        /// <summary>
        /// 開始前ステータスチェック
        /// </summary>
        /// <returns></returns>
        private string StartStatusCheck()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            string msg = "";
            //制御開始重複
            if (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL)
            {
                msg = $"車両制御中です";
                LOGGER.Info(msg);
                return Res.ErrorStatus.F_ERR.Code;
            }

            //画像接続状況
            if (GetCamCommStatus(MainC) != true)
            {
                msg = $"画像解析装置との接続が不正です";
                LOGGER.Info(msg);
                return Res.ErrorStatus.CAM_CONN_ERR.Code;
            }

            //カメラ状態確認
            if (GetCamHeakthStatus(MainC) == OperationConst.C_ABNORMAL)
            {
                msg = $"カメラ状態が不正です。";
                LOGGER.Info(msg);
                return Res.ErrorStatus.B_ERR.Code;
            }

            //接続状態の確認
            if (TvecsCommClStatus != true || TvecsCommSrvStatus != true)
            {
                msg = $"車両通信装置との接続が不正です。";
                LOGGER.Info(msg);
                return Res.ErrorStatus.C_ERR.Code;
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
            return Res.ErrorStatus.NORMAL.Code;
        }

        private PanaSettingData SetPanaSettingData()
        {
            PanaSettingData panaSettingData = new PanaSettingData();

            panaSettingData.constData = new ConstData();
            panaSettingData.constData.actual_angle_wait = C_ACTUAL_ANGLE_WAIT;
            panaSettingData.constData.use_start_yawrate = false;
            panaSettingData.constData.start_yawrate = int.Parse(ConfigurationManager.AppSettings["C_ACCELERATION_MODE"]);
            panaSettingData.constData.first_pos_x = C_FIRST_POS_X;
            panaSettingData.constData.first_pos_y = C_FIRST_POS_Y;
            panaSettingData.constData.first_diff_x = C_DIFF_X;
            panaSettingData.constData.first_diff_y = C_DIFF_Y;
            panaSettingData.constData.first_errmax_cnt = C_ERRMAX_COUNT;
            panaSettingData.constData.score_all_use = C_SCORE_ALLUSE;
            panaSettingData.constData.angle_limit_mode = C_ANGLE_LIMIT_MODE;
            panaSettingData.constData.acceleration_mode = C_ACCELERATION_MODE;
            panaSettingData.constData.include_judge_area_count = C_INCLUDE_JUDGE_AREA_COUNT;
            panaSettingData.constData.rcdlogger_use = C_RCDLOGGER_USE;
            panaSettingData.constData.rcdlogger_path = C_RCDLOGGER_PATH;

            //panaSettingData.first_vector = CommonProc.ToRadian(m_CarInfo.Vector);
            panaSettingData.first_vector = CommonProc.ToRadian(GetCamRcvInfo(MainC).Vector);

            return panaSettingData;
        }
        #endregion

        #region エリア幅調整

        public void SpeedAreaAdjust(double val)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            foreach (SpeedArea area in m_SpeedAreas)
            {
                area.LeftWidth = area.LeftWidth + val >= 0 ? (float)(area.LeftWidth + val) : 0;
                area.RightWidth = area.RightWidth + val >= 0 ? (float)area.RightWidth + val : 0;
            }

            // エリア全体更新
            for (var i = 0; i <= m_SpeedAreas.Count - 1; i++)
            {
                m_SpeedAreas[i].Area = AreaSet(i, m_SpeedAreas[i]);
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        public void SpeedAreaReset(CourseInfo course)
        {
            m_RouteNodes.Clear();
            if (course.CourseArea != null)
            {
                for (int i = 0; i <= course.CourseNode.Count - 1; i++) { m_RouteNodes.Add(course.CourseNode[i].ToRoutenode()); }
            }
            m_SpeedAreas.Clear();
            if (course.CourseArea != null)
            {
                for (int i = 0; i <= course.CourseArea.Count - 1; i++) { m_SpeedAreas.Add(course.CourseArea[i].ToSpeedArea()); }
            }
        }

        #region エリアの各座標値のセット
        public PointF[] AreaSet(int i, SpeedArea NowSpeedArea)
        {
            List<PointF> area = new List<PointF>();
            int ncnt = i + 1;

            double uedge = 0;
            double vertical = 0;

            uedge = m_RouteNodes[ncnt].X - m_RouteNodes[ncnt - 1].X; // 底辺
            vertical = m_RouteNodes[ncnt].Y - m_RouteNodes[ncnt - 1].Y; // 高さ
            double rad = Math.Atan2(vertical, uedge); // ラジアン
            double cosθ = Math.Cos(rad);
            double sinθ = Math.Sin(rad);

            // エリアの頂点座標の計算
            area.Add(new PointF((float)(m_RouteNodes[ncnt - 1].X + NowSpeedArea.RightWidth * sinθ), (float)(m_RouteNodes[ncnt - 1]  .Y - NowSpeedArea.RightWidth * cosθ)));
            area.Add(new PointF((float)(m_RouteNodes[ncnt].X + NowSpeedArea.RightWidth * sinθ), (float)(m_RouteNodes[ncnt].Y - NowSpeedArea.RightWidth * cosθ)));
            area.Add(new PointF((float)(m_RouteNodes[ncnt].X - NowSpeedArea.LeftWidth * sinθ), (float)(m_RouteNodes[ncnt].Y + NowSpeedArea.LeftWidth * cosθ)));
            area.Add(new PointF((float)(m_RouteNodes[ncnt - 1].X - NowSpeedArea.LeftWidth * sinθ), (float)(m_RouteNodes[ncnt - 1].Y + NowSpeedArea.LeftWidth * cosθ)));
            area.Add(area[0]);

            if (i > 0)
            {
                PointF O = new PointF(m_RouteNodes[ncnt - 2].X, m_RouteNodes[ncnt - 2].Y);
                PointF A = new PointF(m_RouteNodes[ncnt - 1].X, m_RouteNodes[ncnt - 1].Y);
                PointF B = new PointF(m_RouteNodes[ncnt].X, m_RouteNodes[ncnt].Y);
                
                double Z = CommonProc.Gaiseki(O, A, B);
                if (Z > 0)
                {
                    area.Insert(4, new PointF(m_RouteNodes[ncnt - 1].X, m_RouteNodes[ncnt - 1].Y));
                    area.Insert(5, m_SpeedAreas[i - 1].Area[1]);
                }
                else if (Z < 0)
                {
                    area.Insert(4, m_SpeedAreas[i - 1].Area[2]);
                    area.Insert(5, new PointF(m_RouteNodes[ncnt - 1].X, m_RouteNodes[ncnt - 1].Y));
                }
            }

            return area.ToArray();
        }

        #endregion

        #endregion

        #region 制御開始応答
        private void EventChatchControlStartStatus(EmergencyEndProcessEventArgs e)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            ControlStartStatus(e.errcd,e.arg1);

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }
        /// <summary>
        /// 制御正常開始応答
        /// </summary>
        private void ControlStartStatus(string status, string camid = "0000")
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");
            
            if (status != Res.ErrorStatus.NORMAL.Code && status != Res.ErrorStatus.F_ERR.Code)
            {
                // 車両通信装置に制御終了指示を送信する
                if (m_carstarted == OperationConst.C_RECEIVED) { CarControlEnd(); }
                //測位終了通知を送信する
                if (GetCamStartRes(MainC) == OperationConst.C_RECEIVED) { ExeCamEnd(MainC); }

                m_CarControlStatus = OperationConst.ControlStatusType.C_NOT_IN_CONTROL;

                // タイマーを止める
                TimerEnd();
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        #endregion

        #region　走行停止解消
        /// <summary>
        /// 走行停止解消チェック
        /// </summary>
        private void EliminationCheck()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            string status = StartStatusCheck();
            //SndEliminationResult sndmsg = new SndEliminationResult();
            //sndmsg.statuscd = status;

            if (status != "")
            {
                //string rcv = m_mcl.SendMessage(sndmsg, false);
                if (status == Res.ErrorStatus.NORMAL.Code)
                {
                    // 待機中へ変更
                    m_EmergencyStop = false;
                }
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }
        #endregion 

        #region 変換
        /// <summary>
        /// stringからcharに変換
        /// </summary>
        public char[] stringToChar(string ErrorString)
        {
            char[] charFive = new char[5];
            for (int i = 0; i < 5; i++) { charFive[i] = ErrorString[i]; }
            return charFive;
        }

        /// <summary>
        /// charからstringに変換
        /// </summary>
        public string charToString(char[] Errorchar)
        {
            string stringFive = new string(Errorchar);
            return stringFive;
        }

        #endregion 

        #region 舵角加速度通知タイマー処理
        /// <summary>
        /// 舵角加速度通知タイマー処理
        /// </summary>
        /// <param name="state"></param>
        private void Callback_Kasoku(object state)
        {
            lock (m_carcontrollock)
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                try
                {
                    //タイマー停止
                    if (m_timer_cc == null) { return; }
                    m_timer_cc.Change(Timeout.Infinite, Timeout.Infinite);
                    
                    if (TvecsCommClStatus == true)
                    {
                        //車両通信端末と画像解析装置から電文を取得するまで車両制御指示は送らない
                        if (m_carstarted == 0 || GetCamStarted(MainC) == 0)
                        {
                            LOGGER.Info("測位情報、車両状態通知受信待ち");
                            return;
                        }

                        //時間計測
                        var sw = new System.Diagnostics.Stopwatch();
                        sw.Start();

                        //加速度舵角を計算して通知送信
                        bool res = KasokuDakakuSnd();

                        //100ms間隔で送信できるように待機
                        sw.Stop();
                        int t = (C_CC_SEND_INTERVAL - C_CC_CALC_WAITTIME) - sw.Elapsed.Milliseconds;
                        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} t=>{t}");
                        if (t < 0) { t = 0; }
                        Thread.Sleep(t);

                        //舵角通知送信
                        if (res)
                        {
                            SpeedAngleSnd();
                        }
                    }
                }
                catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
                catch (Exception ex)
                {
                    LOGGER.Error(ex.Message);
                    EmergencyEndProcess(charToString(m_avpappOutputData.avp_error_code));
                    ExceptionProcess.ComnExceptionConsoleProcess(ex);
                }
                finally
                {
                    int interval = C_CC_CALC_WAITTIME;
                    if (m_timer_cc != null) { m_timer_cc.Change(interval, interval); }
                    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
                }
            }
        }

        /// <summary>
        /// 加速度舵角通知送信
        /// </summary>
        private bool KasokuDakakuSnd()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            //※　各値の取得
            m_panaInputData.camera_id = GetCamRcvInfo(MainC).CamID;
            m_panaInputData.reliability = GetCamRcvInfo(MainC).Reliability;

            m_observedData.observed_vehicle_yaw = CommonProc.ToRadian(GetCamRcvInfo(MainC).MoveVector);
            m_observedData.observed_vehicle_x = GetCamRcvInfo(MainC).xPosition;
            m_observedData.observed_vehicle_y = GetCamRcvInfo(MainC).yPosition;
            m_observedData.observed_data_timestamp = GetCamRcvInfo(MainC).observed_data_timestamp;
            //※

            // 一時停止状態取得
            m_controlCenterData.request_control_status = GetPauseStatus();

            // 送信時間計算
            DateTime serdatetime = DateTime.Now;
            m_sertimespan = serdatetime - m_now;
            m_controlCenterData.timestamp = (uint)Math.Floor(m_sertimespan.TotalMilliseconds);
            LOGGER.Info($"[差分取得]timestamp：{m_controlCenterData.timestamp},");


            string goalCoordinate = null;
            foreach (PointF goalPointF in m_controlCenterData.goalarea)
            {
                goalCoordinate += $@"{goalPointF.X.ToString()},{goalPointF.Y.ToString()}, ";
            }

            LOGGER.Info($@"計測項目（入力） ,→ ,{m_vehicleData.is_vehicle_stop.ToString()} ,{m_vehicleData.vehicle_speed.ToString()} ,{m_vehicleData.steer_angle.ToString()} ,{m_vehicleData.gx.ToString()} ,{m_vehicleData.gy.ToString()} ,{m_vehicleData.yr.ToString()} ,{m_vehicleData.vehicle_data_timestamp.ToString()},{m_vehicleData.steer_torque.ToString()} ,{m_vehicleData.is_steer_torque_invalid.ToString()} ,{m_vehicleData.steer_torque_enhaned.ToString()} ,{m_vehicleData.eps_motor_torque.ToString()} ,{m_vehicleData.is_vehicle_speed_from_vsc_invalid.ToString()} ,{m_vehicleData.sp1_pulse.ToString()} ,{m_vehicleData.vehicle_speed_from_vsc.ToString()} ,{m_vehicleData.request_gx_from_b_pedal.ToString()},{m_vehicleData.request_gx_from_a_pedal.ToString()},{m_vehicleData.estimated_gx_form_vsc.ToString()} ,{m_vehicleData.gvc_invalid.ToString()} ,{m_vehicleData.epb_lock_state.ToString()} ,{m_vehicleData.shift_range_from_vmc.ToString()} ,{m_vehicleData.yawrate_sensor_1_invalid.ToString()} ,{m_vehicleData.yawrate_sensor_2_invalid.ToString()} ,{m_vehicleData.yaw_g_sensor_power_invalid.ToString()},{m_vehicleData.g_sensor_1_invalid.ToString()} ,{m_vehicleData.yaw_g_sensor_type_identification.ToString()},{m_vehicleData.g_sensor_2_invalid.ToString()},{m_observedData.observed_vehicle_x.ToString()} ,{m_observedData.observed_vehicle_y.ToString()} ,{m_observedData.observed_vehicle_yaw.ToString()} ,{m_observedData.observed_data_timestamp.ToString()} ,{m_controlCenterData.timestamp.ToString()}  ,{m_controlCenterData.request_control_status.ToString()},{goalCoordinate}");

            
            //指示値計算
            try
            {
                m_avpappOutputData = (AVPAppOutputData)m_calc.CalcCtrlTargetValue(m_vehicleData, m_observedData, m_controlCenterData, m_panaInputData).Clone();
            }
            catch (Exception e)
            {
                EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
                ExceptionProcess.ComnExceptionConsoleProcess(e);

                SetCarInfo(m_CarInfo, false, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
            }

            //計算ステータス判定
            if (m_avpappOutputData.avp_app_state ==　OperationConst.CalcAppStatus.C_CONTROL_OFF || m_avpappOutputData.avp_app_state == OperationConst.CalcAppStatus.C_CONTROL_PREPARATION || m_avpappOutputData.avp_app_state == OperationConst.CalcAppStatus.C_CONTROL_READY)
            {
                SetCarInfo(m_CarInfo, false, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
                LOGGER.Info($"制御準備中...：{m_avpappOutputData.avp_app_state}");
                return false;
            }
            else if (m_avpappOutputData.avp_app_state == OperationConst.CalcAppStatus.C_CONTROL_NOMAL || m_avpappOutputData.avp_app_state == OperationConst.CalcAppStatus.C_CONTROL_BLACKOUT)
            {
                //車両4隅を計算しエリア外判定をする
                List<CarCornerinfo> carCornerinfo = new List<CarCornerinfo>();
                carCornerinfo = AskContainArea_cornerpoint(new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y), new PointF((float)m_observedData.observed_vehicle_x, (float)m_observedData.observed_vehicle_y), m_avpappOutputData.draw_info.yawrate);
                AskContainArea(new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
                CarCornerinfo result = carCornerinfo.FirstOrDefault(c => c.OutOfArea == true);
                if (result != null)
                {
                    m_outarea++;
                    if (m_outarea > C_CARCORNER_OUTAREA_ALLOW_NUM)
                    {
                        CarCornerinfo carCorner = carCornerinfo.Find(c => c.OutOfArea == true);
                        LOGGER.Error(carCorner.cornerName + $"が範囲外です。異常通知します。x:{carCorner.cornerPoint.X.ToString()} y:{carCorner.cornerPoint.Y.ToString()}");
                        
                        EmergencyEndProcess(Res.ErrorStatus.I_ERR.Code);
                        return false;
                    }
                }
                else
                {
                    m_outarea = 0;
                }
                LOGGER.Debug($"m_outarea値:{m_outarea}");

                try
                {
                    if (m_avpappOutputData.panaOutputData.log == null)
                    {
                        SetCarInfo(m_CarInfo, true, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
                    }
                    else
                    {
                        SetCarInfo(m_CarInfo, m_avpappOutputData.panaOutputData.get, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
                    }
                }
                catch (Exception e)
                {
                    LOGGER.Error("inexception");
                    ExceptionProcess.ComnExceptionProcess(e);
                    SetCarInfo(m_CarInfo, true, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
                }

            }
            else if (m_avpappOutputData.avp_app_state == OperationConst.CalcAppStatus.C_CONTROL_COMPLETE)
            {
                m_goalcomp_flg = 1;
                if (m_senser_check)
                {
                    if (!m_GoalCheckSnd)
                    {
                        //ゴール在籍センサ状態の確認
                        m_GoalCheckSnd = true;
                        //Task.Run(() => GoalSensorStatusCheck());
                    }
                }
                else
                {
                    Task.Run(() => EndProcess());
                }

                SetCarInfo(m_CarInfo, true, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
            }
            else
            {
                EmergencyEndProcess(charToString(m_avpappOutputData.avp_error_code));

                SetCarInfo(m_CarInfo, false, new PointF((float)m_avpappOutputData.control_point.x, (float)m_avpappOutputData.control_point.y));
            }
            
            LOGGER.Info($@"計測項目（出力） ,→ ,{m_avpappOutputData.target_steering_angle.ToString()} ,{m_avpappOutputData.target_gx.ToString()} ,{m_avpappOutputData.control_point.x.ToString()} ,{m_avpappOutputData.control_point.y.ToString()} ,{m_avpappOutputData.draw_info.yawrate.ToString()} ,{m_avpappOutputData.draw_info.angle_guard.ToString()} ,{m_avpappOutputData.draw_info.guard_front_angle.ToString()} ,{m_avpappOutputData.avp_app_state.ToString()} ");

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");

            return true;
        }

        private void SpeedAngleSnd()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            
            LOGGER.Debug($"carNo:{m_CarNo},Speed:{m_avpappOutputData.target_gx},Dakaku:{m_avpappOutputData.target_steering_angle}");

            SndKasokuDakaku snd = new SndKasokuDakaku
            {
                CarNo = m_CarNo,
                Speed = m_avpappOutputData.target_gx,
                Dakaku = (float)m_avpappOutputData.target_steering_angle
            };

            if (TvecsCommClStatus == true) { string strResponse = m_tcl.SendMessage(snd, false); }
            m_calcstarted = OperationConst.C_RECEIVED;
            LOGGER.Info($"[車両通信装置]送信→車両制御指示");

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        #endregion

        #region ### 制御指示送信後タイマー開始 ###
        /// <summary>
        /// 制御指示送信後タイマー開始
        /// </summary>
        /// <param name="state"></param>
        private void Callback_CarStatus(object state)
        {
            try
            {
                //タイマー停止
                if (m_timer_ci == null) { return; }
                m_timer_ci.Change(Timeout.Infinite, Timeout.Infinite);

                if (m_CarControlStatus == OperationConst.ControlStatusType.C_NOT_IN_CONTROL)
                {
                    if (GetCamStartRes(MainC) == OperationConst.C_NOT_RECEIVED || m_CarStartRes == OperationConst.C_NOT_RECEIVED)
                    {
                        LOGGER.Info("制御開始応答待ち");
                        return;
                    }
                    else
                    {
                        ControlStartStatus(Res.ErrorStatus.NORMAL.Code);
                        m_CarControlStatus = OperationConst.ControlStatusType.C_UNDER_CONTROL;
                        TimerStart();
                        m_ci_interval = C_CI_INTERVAL;
                    }
                }

                //if (m_calcstarted == OperationConst.C_NOT_RECEIVED) { return; }

            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
            finally
            {
                if (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL)
                {
                    m_timer_ci.Dispose();
                    m_timer_ci = null;
                }
                else
                {
                    //タイマー再開
                    if (m_timer_ci != null) { m_timer_ci.Change(m_ci_interval, m_ci_interval); }
                }
            }
        }


        private void TimerStart()
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            //その他エリアチェック開始
            OtherAreaCheck();

            // 安全監視
            StartSafetyMonitortringTimer();

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        #endregion

        #region その他エリアチェック
        /// <summary>
        /// その他エリアの範囲チェックを行う
        /// </summary>
        private void OtherAreaCheck()
        {
            try
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                foreach (OtherAreaRetention i in m_otherArea)
                {
                    Task.Run(() => CheckTimer(i));
                }
            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
            finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        }

        private async void CheckTimer(OtherAreaRetention i)
        {
            try
            {
                switch (i.otherarea.AreaCode)
                {
                    case OtherAreaCode.GoalArea:
                        while (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL && i.Done != OperationConst.FacilityAreaStage.C_FACILITY_FIN)
                        {
                            if (i.otherarea.Number == m_ConfigData.GoalNo)
                            {
                                GoalAreaCheck(i);
                            }
                            await Task.Delay(OperationConst.C_OA_INTERVAL).ConfigureAwait(false);
                        }
                        break;
                    case OtherAreaCode.FacilityArea:
                        while (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL && i.Done != OperationConst.FacilityAreaStage.C_FACILITY_FIN)
                        {
                            FacilityAreaCheck(i);
                            await Task.Delay(OperationConst.C_OA_INTERVAL).ConfigureAwait(false);
                        }
                        break;
                    //case OtherAreaCode.GoalChangeStopArea:
                    //    while (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL && i.Done != OperationConst.FacilityAreaStage.C_FACILITY_FIN)
                    //    {
                    //        GoalChangeStopAreaCheck(i);
                    //        await Task.Delay(OperationConst.C_OA_INTERVAL).ConfigureAwait(false);
                    //    }
                    //    break;
                }
            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex)
            {
                ExceptionProcess.ComnExceptionConsoleProcess(ex);

                if (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL)
                {
                    LOGGER.Info($"原因不明のエラーにより走行停止します");
                    EmergencyEndProcess(Res.ErrorStatus.LOOKINGFOR_ERR.Code);
                }
            }
            finally { }
        }

        #region GoalAreaCheck（ゴールエリアの判定を行う）
        /// <summary>
        /// ゴールエリアの判定を行う
        /// </summary>
        /// <param name="i"></param>
        private void GoalAreaCheck(OtherAreaRetention i)
        {
            //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
            if (m_carstarted == 0 || GetCamStarted(MainC) == 0) { return; }

            int idx = i.Done;
            if (PositionInArea(i.otherarea.area[idx]))
            {
                //管制端末からの指示とゴール番号が同じであればゴールと判定
                if (i.otherarea.Number == m_ConfigData.GoalNo)
                {
                    LOGGER.Info("ゴールエリアに侵入しました。");
                    //ゴールフラグを立て、車両状態通知で速度0が来るのを待つ
                    //m_evGoalRcvWait.Reset();
                    m_goal_flg = 1;
                    m_senser_check = i.otherarea.Sensor;
                }
                m_TerminalStatus = Res.CtrlStatus.ARRV_GOAL_AREA.Code;
                i.Done = OperationConst.FacilityAreaStage.C_FACILITY_FIN;

                //車両の停車と在籍センサの待機を待つ
                if (i.otherarea.Sensor)
                {
                    ////受信待機
                    //if (m_evGoalRcvWait.WaitOne(C_SENSORCHECK_DELAY))
                    //{
                    //    string msg = "";
                    //    if (i.otherarea.Number < m_ConfigData.GoalNo)
                    //    {
                    //        msg = "在籍センサの検知を確認しました";
                    //        LOGGER.Info($"{msg}。{m_ConfigData.GoalNo}:{m_ConfigData.GoalNo}");
                    //        Task.Run(() => EndProcess());
                    //    }
                    //    else
                    //    {
                    //        msg = $"在籍センサで検知できません。走行停止します";
                    //        LOGGER.Info($"{msg}。{m_ConfigData.GoalNo}:{m_ConfigData.GoalNo}");
                    //        EmergencyEndProcess(Res.ErrorStatus.P_ERR.Code);
                    //    }
                    //}
                    //else
                    //{
                    //    LOGGER.Info($"在籍エリア応答(ゴール変更通知)を受信できません。走行停止します。");
                    //    EmergencyEndProcess(Res.ErrorStatus.P_ERR.Code);
                    //}
                }
            }
        }
        #endregion

        #region FacilityAreaCheck（周辺設備の範囲判定を行う）
        /// <summary>
        /// 周辺設備の範囲判定を行う
        /// </summary>
        /// <param name="i"></param>
        private void FacilityAreaCheck(OtherAreaRetention i)
        {
            //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
            if (m_carstarted == 0 || GetCamStarted(MainC) == 0) { return; }

            int idx = i.Done;
            if (PositionInArea(i.otherarea.area[idx]))
            {
                OtherArea area = i.otherarea;
                switch (idx)
                {
                    //指示開始エリア
                    case OperationConst.FacilityAreaStage.C_FACILITY_START:
                        //SndFacilityControl sndfcst = new SndFacilityControl();
                        //sndfcst.FacilityID = area.FacilityID;
                        //sndfcst.Command = "1";
                        //string rcvst = "";
                        //for (int count = 1; count <= C_RETRYCOUNT; count++)
                        //{
                        //    try
                        //    {
                        //        rcvst = m_mcl.SendMessage(sndfcst, m_ConfigConst.C_SNDRSESULT_MNG);
                        //        LOGGER.Info($"[管制端末]送信→設備制御指示:{area.FacilityID}.{area.Name}");
                        //        if (m_ConfigConst.C_SNDRSESULT_MNG && rcvst == null) { throw new Exception(); }
                        //        i.Done = OperationConst.FacilityAreaStage.C_FACILITY_CHECK;
                        //        break;
                        //    }
                        //    catch
                        //    {
                        //        if (count == C_RETRYCOUNT)
                        //        {
                        //            LOGGER.Info($"設備制御指示送信失敗。走行停止します。");
                        //            EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
                        //            return;
                        //        }

                        //        LOGGER.Info($"設備制御指示送信失敗。再送信します。");
                        //    }
                        //}
                        //if (m_ConfigConst.C_SNDRSESULT_MNG)
                        //{
                        //    string msgid = CommMsgBase.GetMsgID(rcvst);
                        //    RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvst);
                        //    if (msgid == RcvRsultRcvMsg.msgId)
                        //    {
                        //        LOGGER.Info($"設備制御指示応答受信:{rcvst}");
                        //    }
                        //}
                        LOGGER.Info($"設備動作開始エリアへ侵入しました。動作を開始します。設備ID:{area.FacilityID}");
                        SetFacilityRequestedStatus(area.FacilityID, 1);
                        break;
                    //指示終了エリア
                    case OperationConst.FacilityAreaStage.C_FACILITY_END:
                        //SndFacilityControl sndfcend = new SndFacilityControl();
                        //sndfcend.FacilityID = area.FacilityID;
                        //sndfcend.Command = "0";
                        //string rcvend = "";
                        //for (int count = 1; count <= C_RETRYCOUNT; count++)
                        //{
                        //    try
                        //    {
                        //        rcvend = m_mcl.SendMessage(sndfcend, m_ConfigConst.C_SNDRSESULT_MNG);
                        //        LOGGER.Info($"[管制端末]送信→設備制御指示:{area.FacilityID}.{area.Name}");
                        //        if (m_ConfigConst.C_SNDRSESULT_MNG && rcvend == null) { throw new Exception(); }
                        //        i.Done = OperationConst.FacilityAreaStage.C_FACILITY_FIN;
                        //        break;
                        //    }
                        //    catch
                        //    {
                        //        if (count == C_RETRYCOUNT)
                        //        {
                        //            LOGGER.Info($"設備制御指示送信失敗。走行停止します。");
                        //            EmergencyEndProcess(Res.ErrorStatus.FACILITY_ERR.Code);
                        //            return;
                        //        }

                        //        LOGGER.Info($"設備制御指示送信失敗。再送信します。");
                        //    }
                        //}
                        //if (m_ConfigConst.C_SNDRSESULT_MNG)
                        //{
                        //    string msgid = CommMsgBase.GetMsgID(rcvend);
                        //    RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvend);
                        //    if (msgid == RcvRsultRcvMsg.msgId)
                        //    {
                        //        LOGGER.Info($"設備制御指示応答受信:{rcvend}");
                        //    }
                        //}
                        LOGGER.Info($"設備動作終了エリアへ侵入しました。動作を開始します。設備ID:{area.FacilityID}");
                        SetFacilityRequestedStatus(area.FacilityID, 0);
                        break;
                    //指示完了確認エリア
                    case OperationConst.FacilityAreaStage.C_FACILITY_CHECK:
                        if (i.status == 0)
                        {
                            LOGGER.Info($"設備制御未完了のため走行停止します。設備：{i.otherarea.FacilityID}.{area.Name}");
                            EmergencyEndProcess(Res.ErrorStatus.FACILITY_RES_ERR.Code, OperationConst.ErrType.C_PT_FACILITY, i.otherarea.FacilityID, "1");

                        }
                        else
                        {
                            //動作後であれば一時停止せず進める
                            i.Done = OperationConst.FacilityAreaStage.C_FACILITY_END;
                        }
                        break;
                }
            }
        }
        #endregion

        #region GoalChangeStopAreaCheck（ゴールエリア判定通知の送信を行う）
        //private void GoalChangeStopAreaCheck(OtherAreaRetention i)
        //{
        //    //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
        //    if (m_carstarted == 0 || GetCamStarted(MainC) == 0) { return; }

        //    int idx = i.Done;
        //    if (PositionInArea(i.otherarea.area[idx]))
        //    {
        //        SndGoalChangeStop sndmsg = new SndGoalChangeStop();

        //        string rcvmsg = "";

        //        for (int count = 1; count <= C_RETRYCOUNT; count++)
        //        {
        //            try
        //            {
        //                LOGGER.Info($"[管制端末]送信→ゴールエリア判定通知");
        //                m_evCheckRcvWait.Reset();
        //                rcvmsg = m_mcl.SendMessage(sndmsg, m_ConfigConst.C_SNDRSESULT_MNG);
        //                if (m_ConfigConst.C_SNDRSESULT_MNG && rcvmsg == null) { throw new Exception(); }
        //                i.Done = OperationConst.FacilityAreaStage.C_FACILITY_FIN;
        //                break;
        //            }
        //            catch
        //            {
        //                if (count == C_RETRYCOUNT)
        //                {
        //                    LOGGER.Info($"ゴールエリア判定通知送信失敗。走行停止します。");
        //                    EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //                    m_evCheckRcvWait.Set();
        //                    return;
        //                }

        //                LOGGER.Info($"ゴールエリア判定通知送信失敗。再送信します。");
        //            }
        //        }

        //        if (m_ConfigConst.C_SNDRSESULT_MNG)
        //        {
        //            string msgid = CommMsgBase.GetMsgID(rcvmsg);
        //            RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvmsg);
        //            if (msgid == RcvRsultRcvMsg.msgId)
        //            {
        //                LOGGER.Info($"ゴールエリア判定通知応答受信:{rcvmsg}");
        //            }
        //        }

        //        //受信確認
        //        if (m_evCheckRcvWait.WaitOne(m_ConfigConst.C_GOALCHECK_DELAY))
        //        {

        //        }
        //        else
        //        {
        //            LOGGER.Info($"ゴールエリア判定結果を受信できません。走行停止します。");
        //            EmergencyEndProcess(Res.ErrorStatus.Q_ERR.Code);
        //        }
        //    }
        //}
        #endregion

        #region 現在測位点のエリアに対する内包判定
        public Boolean PositionInArea(PointF[] area)
        {
            bool contain = false;
            //旧前方注視点->リア軸中心？？
            PointF point = new PointF(m_newPPoint.X, m_newPPoint.Y);

            contain = CommonProc.PointInPolygon(point, area);

            return contain;
        }
        #endregion

        #endregion

        #region 測位点取得

        private void SetCarInfo(CarInfo info, bool get, PointF newp)
        {
            PointF p = new PointF(info.xPosition, info.yPosition);

            PointF p1 = newp;

            if (get)
            {
                m_ErrCnt = 0;

                //測位点取得(更新)
                AddCarInfo(info, p);
                m_newPPoint = p1;
            }
            else
            {
                //取得範囲外測位点情報保持
                m_ErrCnt++;
                //LOGGER.Info($"測位点取得範囲外のため測位位置をスルーします{{{m_ErrCnt}}}。x:{info.xPosition.ToString()} y:{info.yPosition.ToString()}");
            }
        }
        /// <summary>
        /// ※測位点を取得する（走行履歴をストックする）
        /// </summary>
        /// <param name="info"></param>
        /// <param name="p"></param>
        private void AddCarInfo(CarInfo info, PointF p)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            CarInfo CarStatus = new CarInfo();
            CarStatus.angle = info.angle;
            CarStatus.xPosition = p.X;
            CarStatus.yPosition = p.Y;
            CarStatus.speed = info.speed;
            CarStatus.Yawrate = info.Yawrate;
            CarStatus.YawrateTime = info.YawrateTime;

            //PointF LPoint = toLocalCoordinate(new PointF(p.X, p.Y));
            //m_CarStatusList.Add(CarStatus);
            //m_CarStatusListLPoint.Add(LPoint);

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }
        #endregion

        #region 走行エリア判定
        /// <summary>
        ///  現在地から属するエリアのノードを返す
        /// </summary>
        /// <param name="point1">リア軸中心</param>
        /// <returns></returns>
        public void AskContainArea(PointF point1)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            bool contain = false;
            int idx = -1;

            PointF p = point1;

            //エリア内包判定
            if (m_contain_idx == -1)
            {
                //先頭から判定をする
                for (int i = 0; i <= m_SpeedAreas.Count() - 1; i++)
                {
                    if (CommonProc.PointInPolygon(p, m_SpeedAreas[i].Area))
                    {
                        contain = true;
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                int cnt = C_INCLUDE_JUDGE_AREA_COUNT;
                int fromidx = (m_contain_idx <= cnt) ? 0 : m_contain_idx - cnt;
                int toidx = (m_SpeedAreas.Count() - 1 <= m_contain_idx + cnt) ? m_SpeedAreas.Count() - 1 : m_contain_idx + cnt;
                //前回内包していたエリアの前後のみ確認する
                for (int i = toidx; i >= fromidx; i--)
                {
                    if (CommonProc.PointInPolygon(p, m_SpeedAreas[i].Area))
                    {
                        contain = true;
                        idx = i;
                        break;
                    }
                }
            }

            //エリア内であるとき
            if (contain)
            {
                m_contain_idx = idx;
            }
            //エリア外であるとき
            if (!contain)
            {
                LOGGER.Info($"現在地が設定エリア外です。制御点-X:{point1.X.ToString()} Y:{point1.Y.ToString()}");
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }


        public List<CarCornerinfo> AskContainArea_cornerpoint(PointF rearPoint, PointF point2, double yawrate)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            List<PointF> cornersPoint = new List<PointF>();
            cornersPoint = CalcCorners(rearPoint.X, rearPoint.Y, yawrate);

            foreach (PointF corner in cornersPoint)
            {
                if (m_CarCornerinfo.Count() < cornersPoint.Count())
                {
                    m_CarCornerinfo.Add(new CarCornerinfo
                    {
                        cornerName = m_cornername[cornersPoint.IndexOf(corner)],
                        containAreaidx = -1,
                        OutOfArea = false,
                        cornerPoint = corner
                    });
                }

                bool contain = false;
                int idx = -1;

                PointF p = corner;

                //エリア内包判定
                if (m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx == -1)
                {
                    //先頭から判定をする
                    for (int i = 0; i <= m_SpeedAreas.Count() - 1; i++)
                    {
                        if (CommonProc.PointInPolygon(p, m_SpeedAreas[i].Area))
                        {
                            contain = true;
                            idx = i;
                            m_CarCornerinfo[cornersPoint.IndexOf(p)].cornerPoint = corner;
                            break;
                        }
                    }
                }
                else
                {

                    int cnt = C_INCLUDE_JUDGE_AREA_COUNT;
                    int fromidx = (m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx <= cnt) ? 0 : m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx - cnt;
                    int toidx = (m_SpeedAreas.Count() - 1 <= m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx + cnt) ? m_SpeedAreas.Count() - 1 : m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx + cnt;
                    //前回内包していたエリアの前後のみ確認する
                    for (int i = toidx; i >= fromidx; i--)
                    {
                        if (CommonProc.PointInPolygon(p, m_SpeedAreas[i].Area))
                        {
                            contain = true;
                            idx = i;
                            m_CarCornerinfo[cornersPoint.IndexOf(p)].cornerPoint = corner;
                            m_CarCornerinfo[cornersPoint.IndexOf(p)].OutOfArea = true;
                            break;
                        }
                    }
                }
                //エリア外であるとき
                m_CarCornerinfo[cornersPoint.IndexOf(p)].OutOfArea = false;
                if (!contain)
                {
                    LOGGER.Info($"現在地が設定エリア外です。制御点-X:{corner.X.ToString()} Y:{corner.Y.ToString()} 測位点-X:{point2.X.ToString()} Y:{point2.Y.ToString()}");
                    m_CarCornerinfo[cornersPoint.IndexOf(p)].OutOfArea = true;
                    m_CarCornerinfo[cornersPoint.IndexOf(p)].cornerPoint = corner;
                    //break;
                }
                else
                {
                    if (m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx == -1)
                    {
                        m_CarCornerinfo[cornersPoint.IndexOf(p)].containAreaidx = idx;
                    }
                    else if (cornersPoint.IndexOf(p) == 0 || cornersPoint.IndexOf(p) == 3)
                    {
                        m_CarCornerinfo[0].containAreaidx = idx;
                        m_CarCornerinfo[3].containAreaidx = idx;
                        LOGGER.Debug($"m_CarCornerinfo[0,3].containAreaidx:{idx}");
                    }
                    else if (cornersPoint.IndexOf(p) == 1 || cornersPoint.IndexOf(p) == 2)
                    {
                        m_CarCornerinfo[1].containAreaidx = idx;
                        m_CarCornerinfo[2].containAreaidx = idx;
                        LOGGER.Debug($"m_CarCornerinfo[1,2].containAreaidx:{idx}");
                    }
                }
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
            return m_CarCornerinfo;
        }

        /// <summary>
        /// 後輪軸中心座標から車両4隅の計算する
        /// </summary>
        /// <returns></returns>
        public List<PointF> CalcCorners(double rearCenterx, double rearCentery, double carYawrate)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            LOGGER.Debug($"車両前長さ{m_carSpec.CenterFrontLength},車両後ろ長さ{m_carSpec.CenterEndLength},車両全幅{m_carSpec.WidthDistance},車両ヨーレート{carYawrate},車両リア軸x{rearCenterx},車両リア軸y{rearCentery}");

            double LCY = m_carSpec.CenterFrontLength * Math.Cos(carYawrate);
            double LLCY = m_carSpec.CenterEndLength * Math.Cos(carYawrate);
            double LSY = m_carSpec.CenterFrontLength * Math.Sin(carYawrate);
            double LLSY = m_carSpec.CenterEndLength * Math.Sin(carYawrate);

            double TCY = (m_carSpec.WidthDistance / 2) * Math.Cos(carYawrate);
            double TSY = (m_carSpec.WidthDistance / 2) * Math.Sin(carYawrate);

            List<PointF> corners = new List<PointF>();
            PointF corner = new PointF();
            corner.X = (float)(rearCenterx - LLCY - TSY);
            corner.Y = (float)(rearCentery - LLSY + TCY);

            corners.Add(corner);

            corner.X = (float)(rearCenterx + LCY - TSY);
            corner.Y = (float)(rearCentery + LSY + TCY);

            corners.Add(corner);

            corner.X = (float)(rearCenterx + LCY + TSY);
            corner.Y = (float)(rearCentery + LSY - TCY);

            corners.Add(corner);

            corner.X = (float)(rearCenterx - LLCY + TSY);
            corner.Y = (float)(rearCentery - LLSY - TCY);

            corners.Add(corner);

            LOGGER.Info($"左後端:({corners[0].X.ToString()},{corners[0].Y.ToString()}), 左前端:({corners[1].X.ToString()},{corners[1].Y.ToString()}), 右前端:({corners[2].X.ToString()},{corners[2].Y.ToString()}), 右後端:({corners[3].X.ToString()},{corners[3].Y.ToString()}),");
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");

            return corners;
        }

        #endregion

        #region 通常制御終了
        /// <summary>
        /// 制御正常終了時の処理を行う
        /// </summary>
        private void EndProcess()
        {
            try
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                LOGGER.Info("制御正常終了処理を開始します。");
                try
                {
                    // 車両通信装置に制御終了指示を送信する
                    CarControlEnd();

                    //測位終了通知を送信する
                    ExeCamEnd(MainC);

                    // タイマーを止める
                    TimerEnd();

                    m_CarControlStatus = OperationConst.ControlStatusType.C_NOT_IN_CONTROL;

                }
                catch
                {
                    EmergencyEndProcess(Res.ErrorStatus.O_ERR.Code);
                }
            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex)
            {
                AppLog.GetInstance().Error(ex.Message);
                AppLog.GetInstance().Error(ex.StackTrace);
            }
            finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        }
        #endregion

        #region 走行停止

        public void EventChatchEmergency(EmergencyEndProcessEventArgs e)
        {
            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

            if (m_CarControlStatus == OperationConst.ControlStatusType.C_UNDER_CONTROL && m_error_flg == OperationConst.C_NORMAL)
            {
                EmergencyEndProcess(e.errcd, e.errtype, e.arg1, e.arg2);
            }
            else
            {
                LOGGER.Info("制御外のため走行停止終了処理イベントをスキップします。");
            }

            AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        }

        /// <summary>
        /// 異常終了時の終了処理を行う(全てに通知)
        /// </summary>
        private void EmergencyEndProcess(string errcd, string Pt = null, string arg1 = null, string arg2 = null)
        {
            try
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                LOGGER.Info("走行停止終了処理を開始します。");
                if (m_error_flg == OperationConst.C_NORMAL)
                {
                    m_error_flg = OperationConst.C_ABNORMAL;

                    //車両通信装置へ走行停止通知を送信する
                    if (TvecsCommClStatus == true) { Task.Run(() => EmergencyStop()); }

                    //測位終了通知を送信する
                    if (GetCamCommStatus(MainC) == true) { Task.Run(() => ExeCamEnd(MainC)); }

                    // タイマーを止める
                    TimerEnd();

                    //ステータス表示変更
                    m_EmergencyStop = true;
                    m_CarControlStatus =OperationConst.ControlStatusType.C_NOT_IN_CONTROL;

                }
                else
                {
                    LOGGER.Info("走行停止終了処理開始済み。");
                }
            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex)
            {
                AppLog.GetInstance().Error(ex.Message);
                AppLog.GetInstance().Error(ex.StackTrace);
            }
            finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        }

        #endregion

        #region 車両からの走行停止
        /// <summary>
        /// 車両からの異常通知
        /// </summary>
        private void CarEmergencyEnd(string errcd)
        {
            try
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                LOGGER.Info("走行停止終了処理を開始します。");
                if (m_error_flg == OperationConst.C_NORMAL)
                {
                    m_error_flg = OperationConst.C_ABNORMAL;

                    //測位終了通知を送信する
                    if (GetCamCommStatus(MainC) == true) { Task.Run(() => ExeCamEnd(MainC)); }

                    // タイマーを止める
                    TimerEnd();

                    if (m_calc != null) { m_calc.DeleteClsCalculator(); }

                    //ステータス表示パネル表示
                    m_EmergencyStop = true;

                    m_CarControlStatus = OperationConst.ControlStatusType.C_NOT_IN_CONTROL;
                }
                else
                {
                    LOGGER.Info("走行停止終了処理開始済み。");
                }

            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex)
            {
                AppLog.GetInstance().Error(ex.Message);
                AppLog.GetInstance().Error(ex.StackTrace);
            }
            finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        }
        #endregion

        #region 制御中タイマー停止
        /// <summary>
        /// 制御中に動作しているタイマーを止める
        /// </summary>
        private void TimerEnd()
        {
            try
            {
                AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

                // 加速度舵角を送るのをやめる
                if (m_timer_cc != null)
                {
                    m_timer_cc.Dispose();
                    m_timer_cc = null;
                    LOGGER.Info("加速度舵角送信タイマー停止");
                }

                if (C_SURVEILLANCE_CAR)
                {
                    //車両通信装置受信間隔
                    if (m_timer_tRcv_pause != null)
                    {
                        m_timer_tRcv_pause.Dispose();
                        m_timer_tRcv_pause = null;
                        LOGGER.Info("車両通信装置受信タイマー停止(一時停止)");
                    }
                    if (m_timer_tRcv_stop != null)
                    {
                        m_timer_tRcv_stop.Dispose();
                        m_timer_tRcv_stop = null;
                        LOGGER.Info("車両通信装置受信タイマー停止(走行停止)");
                    }
                }

                //安全監視タイマー停止
                StopSafetyMonitortringTimer();

                m_CarControlStatus =　OperationConst.ControlStatusType.C_NOT_IN_CONTROL;

            }
            catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
            catch (Exception ex)
            {
                AppLog.GetInstance().Error(ex.Message);
                AppLog.GetInstance().Error(ex.StackTrace);
            }
            finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        }
        #endregion

        #region ## エラーメッセージ取得 ##
        public string ErrorStatusGetMsg(string code)
        {
            string msg = null;
            SystemMessage system = m_SystemMsg.SingleOrDefault(c => c.Code == code);
            //msg = m_SystemMsg.SingleOrDefault(c => c.Code == code).Msg;
            //if (msg == null) { msg = new Res.ErrorStatus().GetMsg(code); }

            msg = system != null ? system.Msg : new Res.ErrorStatus().GetMsg(code);

            return msg;
        }
        #endregion

        #region 移行前変数
        //private string m_CheckedCamID = "";

        //private clsCalculator m_calc;

        ////private LogForm m_logform = new LogForm();
        ////private DrawConfigForm m_drawform = new DrawConfigForm();
        //private Queue<string> m_invokequeue = new Queue<string>();
        ////private ConfigConst m_ConfigConst;
        //private ViewerConst m_ViewerConst;
        //private ManualResetEvent m_evCheckRcvWait;
        //private ManualResetEvent m_evGoalRcvWait;
        //private ManualResetEvent m_CamReceiveWait;

        //private ManualResetEvent m_GetVectorWait;
        //private CarSearchRes m_CarSearchResult;
        //private bool m_GoalCheckSnd = false;
        ///// <summary>
        ///// 管制端末へサーバー接続
        ///// </summary>
        ////private CommSrv m_msrv;
        ///// <summary>
        ///// 管制端末へクライアント接続
        ///// </summary>
        //private CommCl m_mcl;

        ///// <summary>
        ///// 車両通信装置へサーバー接続
        ///// </summary>
        ////private CommSrv m_tsrv;


        ///// <summary>
        ///// 管制端末へUDP送信用
        ///// </summary>
        //private CommUdpCl m_mcludp;

        ////private ConfigData m_ConfigData = new ConfigData();
        //private CalcInfo m_CalcInfo = new CalcInfo();
        //private OrderInfo m_OrderInfo = new OrderInfo();
        //private OtherAreaRetention[] m_otherArea;
        ////private List<CamMaster> m_CamList = new List<CamMaster>();

        //private string m_CarSpec = "";
        //private string m_TerminalStatus;
        //private bool m_EmergencyStop;

        //#region 接続確認フラグ
        ///// <summary>
        /////管制端末クライアント接続状況　0:未接続 1:接続
        ///// </summary>
        //private int m_mcl_flag = 0;
        ///// <summary>
        /////管制端末クライアント接続状況　0:未接続 1:接続
        ///// </summary>
        ////private int m_msrv_flag = 0;


        ///// <summary>
        /////TVECSクライアント接続状況　0:未接続 1:接続
        ///// </summary>
        //private int m_tsrv_flag = 0;
        //#endregion

        //#region タイマー
        ///// <summary>
        ///// 再描画タイマー
        ///// </summary>
        //System.Threading.Timer m_timer_rd;

        ///// <summary>
        ///// 舵角加速度値通知タイマー
        ///// </summary>
        //System.Threading.Timer m_timer_cc;
        ///// <summary>
        ///// 車両情報送信タイマー
        ///// </summary>
        //System.Threading.Timer m_timer_ci;
        ///// <summary>
        ///// 管制通信ヘルスチェック_送信
        ///// </summary>
        //System.Threading.Timer m_timer_mhc_snd;
        ///// <summary>
        ///// 管制通信ヘルスチェック_受信
        ///// </summary>
        //System.Threading.Timer m_timer_mhc_rcv;

        ///// <summary>
        ///// 車両前進タイマー
        ///// </summary>
        //System.Threading.Timer m_timer_carmove = null;
        //#endregion

        //#region ロック
        //private object m_redrawlock = new object();

        //private object m_carcontrollock = new object();
        //private object m_carstatuslock = new object();
        //private object m_masterlock = new object();
        //private object m_camsndlock = new object();
        //#endregion

        ///// <summary>
        ///// 車両進行フラグ false:車両前進開始前
        ///// </summary>
        //private bool m_carmovestart_flg = false;
        ///// <summary>
        ///// 車両前進前エラー測位点カウント
        ///// </summary>
        //private int m_errcount = 0;
        ///// <summary>
        ///// 車両制御状態 1:制御中
        ///// </summary>
        //private int m_CarControlStatus = 0;
        ///// <summary>
        ///// ヘルスチェック状態 0:正常 1:異常
        ///// </summary>
        //private int m_camht_status = -1;
        ///// <summary>
        ///// 制御状態 0:正常 1:異常
        ///// </summary>
        //private int m_error_flg = 0;

        //#region 一時停止
        ///// <summary>
        ///// 一時停止状態 0:正常 1:一時停止
        ///// </summary>
        //private int m_pause_flg = 0;
        ///// <summary>
        ///// 一時停止状態(ゴール判定) 0:正常 1:一時停止
        ///// </summary>
        //private int m_pause_goal_flg = 0;

        ///// <summary>
        ///// 一時停止状態(通信) 0:正常 1:一時停止
        ///// </summary>
        //private int m_pause_commP_flg = 0;
        ///// <summary>
        ///// 一時停止状態(TVECS制御) 0:正常 1:一時停止
        ///// 2022/11/17 ADD
        ///// </summary>
        //private int m_pause_tvecs_control_state_flg = 0;
        //#endregion

        ///// <summary>
        ///// ゴール状況
        ///// </summary>
        //private int m_goal_flg = 0;
        ///// <summary>
        ///// ゴール後停止状況
        ///// </summary>
        //private int m_goalcomp_flg = 0;
        ///// <summary>
        ///// 在籍センサ確認
        ///// </summary>
        //private bool m_senser_check = true;

        ///// <summary>
        ///// 測位情報通知 0:未
        ///// </summary>
        //private int m_camstarted = 0;
        ///// <summary>
        ///// 車両制御送信開始 0:未
        ///// </summary>
        //private int m_calcstarted = 0;

        ///// <summary>
        ///// 制御開始受信状況 0:未
        ///// </summary>
        //private int m_ControlStart = 0;

        //private int m_ci_interval = 100;

        //private bool m_FormClosing = false;

        ////DataGridViewRow[] m_rows;

        ///// <summary>
        ///// 現在のヘルスチェック確認対象カメラ(測位カメラ)
        ///// </summary>
        //private string m_NowCamID = "";
        //private bool m_ResetSnd = false;
        //private int m_HealthErrCnt = 0;
        //private int m_HealthErrCnt9 = 0;

        ///// <summary>
        ///// 
        ///// </summary>
        //private bool m_GoalAreaFilled = false;

        //private string m_CamShiftCheckStatus = Res.CamShiftStatus.NOT_ACTIVATE.Code;
        //private string m_error_camid = "0000";



        ///// <summary>
        ///// 無線遅延時ベクトル再取得処理開始有無 (true:実施中,false:未実施)
        ///// </summary>
        //private bool m_vectorreget_start = false;

        ////↓ 2022/12/22 ADD
        //private int m_Act4Out_cnt = 0;
        ////↑
        #endregion

        #region 移行前処理

        //#region ロード
        //private void MainForm_Load(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //        LOGGER.Info("アプリを起動します。");
        //        m_TerminalStatus = Res.CtrlStatus.IDLE.Code;

        //        //コンフィグの読み込み
        //        SetAppConfig();


        //        //初期処理
        //        firstprocess();

        //        //その他エリア描画設定
        //        OtherAreaDrawSet();

        //        //ログ出力フォルダ
        //        if (m_ConfigConst.C_RCDLOGGER_USE)
        //        {
        //            if (!Directory.Exists($"{m_ConfigConst.C_RCDLOGGER_PATH}")) { Directory.CreateDirectory($"{m_ConfigConst.C_RCDLOGGER_PATH}"); }
        //        }

        //        //スタートカメラ設定
        //        m_nowCamID = m_ConfigConst.C_START_CAM_ID;

        //        LOGGER.Info("アプリ起動が完了しました。");
        //    }
        //    catch (UserException ue)
        //    {
        //        ExceptionProcess.UserExceptionProcess(ue);
        //        this.Close();
        //    }
        //    catch (Exception ex)
        //    {
        //        ExceptionProcess.ComnExceptionProcess(ex);
        //        this.Close();
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}


        ///// <summary>
        ///// 初期動作
        ///// </summary>
        //private void firstprocess()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    //設定ファイル読み込み
        //    LoadFile();

        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}

        ///// <summary>
        ///// 設定ファイル読み込み
        ///// </summary>
        //private void LoadFile()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    try
        //    {
        //        if (File.Exists(m_ViewerConst.C_CONFIG_FILE_PATH))
        //        {
        //            System.Xml.Serialization.XmlSerializer xml = new System.Xml.Serialization.XmlSerializer(typeof(ConfigData));
        //            using (System.IO.FileStream fs = new System.IO.FileStream(m_ViewerConst.C_CONFIG_FILE_PATH, FileMode.Open, FileAccess.Read, FileShare.Read))
        //            {
        //                m_ConfigData = (ConfigData)xml.Deserialize(fs);
        //            }

        //            //設定値反映
        //            SetConfig();
        //        }
        //        else
        //        {
        //            throw new Exception();
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        throw new UserException("設定ファイルが不正です");
        //    }

        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}


        //private void SetConfig()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");


        //    Viewer.ViewSetConfig((ConfigData)m_ConfigData.Clone(), true, LOGGER);

        //    //補正なしカメラリスト作成
        //    //m_filter.SetNoFixCam(m_ConfigData.nofixcam);
        //    m_calc = new clsCalculator((ConfigData)m_ConfigData.Clone(), (ViewerConst)m_ViewerConst.Clone());

        //    //その他エリアセット
        //    m_otherArea = new OtherAreaRetention[m_ConfigData.OtherAreas.Count()];
        //    for (int i = 0; i <= m_ConfigData.OtherAreas.Count() - 1; i++)
        //    {
        //        m_otherArea[i] = new OtherAreaRetention
        //        {
        //            otherarea = new OtherArea()
        //        };
        //        m_otherArea[i].otherarea = m_ConfigData.OtherAreas[i];
        //        m_otherArea[i].Done = C_FACILITY_START;
        //    }

        //    //制御描画設定
        //    switch (Properties.Settings.Default.C_DRAW_MODE)
        //    {
        //        case C_DRAW_ANGLE:
        //            //舵角表示
        //            Viewer.AngleDrawChange(true, false);
        //            break;
        //        case C_DRAW_GETAREA:
        //            //測位点取得範囲表示
        //            Viewer.AngleDrawChange(false, true);
        //            break;
        //    }

        //    Viewer.DrawSet();

        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}

        //#endregion

        //#region クローズ
        //private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        //制御中であれば閉じない
        //        if (m_CarControlStatus == C_UNDER_CONTROL)
        //        {
        //            e.Cancel = true;
        //        }
        //        else
        //        {
        //            m_FormClosing = true;

        //            //各接続を切る
        //            alldisconnect(false);

        //            m_calc.ClsCalculatorReleaseMemory();
        //            m_calc = null;
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionProcess(ex); }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        //private void SaveProperties()
        //{
        //    //描画状態の保存
        //    List<int> vs = new List<int>();
        //    for (int i = 0; i <= m_drawform.dgv_otherarea.RowCount - 1; i++)
        //    {
        //        string b = m_drawform.dgv_otherarea.Rows[i].Cells[0].Value.ToString();
        //        if (b == bool.TrueString) { vs.Add(i); }
        //    }
        //    Properties.Settings.Default.C_DRAW_OTHERAREA = String.Join(",", vs); ;
        //    Properties.Settings.Default.Save();
        //}
        //#endregion

        //#region 接続/切断イベント

        //#region 管制端末

        //private void mClConnected(ClientConnectedEventArgs e)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        m_mcl_flag = 1;
        //        LOGGER.Info("管制端末と接続しました");
        //        m_logform.mlog_Insert("管制端末と接続しました");
        //        lbl_sign_mcl.BackColor = Color.LawnGreen;

        //        m_timer_mhc_snd = new System.Threading.Timer(new TimerCallback(Master_HealthCheck), null, Timeout.Infinite, 0);
        //        m_timer_mhc_snd.Change(0, m_ConfigConst.C_MHT_INTERVAL);

        //        m_timer_mhc_rcv = new System.Threading.Timer(new TimerCallback(Master_HealthCheck_TimeOut), null, Timeout.Infinite, 0);
        //        m_timer_mhc_rcv.Change(m_ConfigConst.C_MHT_WAITTIME, m_ConfigConst.C_MHT_WAITTIME);
        //    }

        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        //private void mClDisConnected(ClientConnectedEventArgs e)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        m_mcl_flag = 0;
        //        LOGGER.Info("管制端末と切断しました");
        //        if (m_FormClosing == false) { m_logform.mlog_Insert("管制端末と切断しました"); }
        //        lbl_sign_mcl.BackColor = Color.Red;

        //        //制御中に切断された場合
        //        if (m_CarControlStatus == C_UNDER_CONTROL)
        //        {
        //            EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);

        //            //ステータス表示パネル表示
        //            Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_IDLE);
        //            m_EmergencyStop = false;
        //        }

        //        if (m_timer_mhc_snd != null)
        //        {
        //            m_timer_mhc_snd.Dispose();
        //            m_timer_mhc_snd = null;
        //        }

        //        if (m_timer_mhc_rcv != null)
        //        {
        //            m_timer_mhc_rcv.Dispose();
        //            m_timer_mhc_rcv = null;
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        //#endregion

        //#endregion

        //#region 一括接続切断
        ///// <summary>
        ///// すべての接続を接続状態にする
        ///// </summary>
        ///// <param name="btnchange">ボタンの活性・非活性を変更するか</param>
        //private void allconnect(Boolean btnchange)
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    m_mcl.Connect();
        //    m_panacl.Connect();
        //    m_tsrv.StartListen();
        //    m_tcl.Connect();


        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}

        ///// <summary>
        ///// すべての接続を切断する
        ///// </summary>
        ///// <param name="btnchange">ボタンの活性・非活性を変更するか</param>
        //private void alldisconnect(Boolean btnchange)
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    //if (btn_mclDisConnect.Enabled) { m_mcl?.Disconnect(true); }
        //    if (btn_mclDisConnect.Enabled) { btn_mDisConnect_Click(null, null); }
        //    //if (btn_pDisConnect.Enabled) { m_pcl?.Disconnect(true); }
        //    if (btn_pDisConnect.Enabled) { btn_pDisConnect_Click(null, null); }
        //    //m_tsrv?.EndListen(true);
        //    if (btn_tsrvDisConnect.Enabled) { btn_tsrvDisConnect_Click(null, null); }
        //    //if (btn_tclDisConnect.Enabled) { m_tcl.Disconnect(true); }
        //    if (btn_tclDisConnect.Enabled) { btn_tclDisConnect_Click(null, null); }

        //    //if (btnchange) { alldisconnect_btn(); }

        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}
        //#endregion

        //#region タイマー(スレッド)処理

        //#region 制御端末ヘルスチェック
        //private void Master_HealthCheck(object state)
        //{
        //    lock (m_masterlock)
        //    {
        //        try
        //        {
        //            //タイマー停止
        //            if (m_timer_mhc_snd == null) { return; }
        //            m_timer_mhc_snd.Change(Timeout.Infinite, Timeout.Infinite);

        //            //メッセージ送信
        //            SndMHealthCheck sndmsg = new SndMHealthCheck();
        //            sndmsg.TerminalID = m_ConfigConst.C_TERMINAL_ID;
        //            sndmsg.status = TerminalHealthCheck();
        //            if (m_mcl_flag == 1)
        //            {
        //                //m_evHealthRcvWait.Reset();
        //                string Receivemsg = m_mcl.SendMessage(sndmsg, false);
        //                LOGGER.Info("管制端末へヘルスチェックを送信しました。");
        //            }

        //            //if (m_evHealthRcvWait.WaitOne(m_ConfigConst.C_MHT_WAITTIME))
        //            //{

        //            //}
        //            //else
        //            //{
        //            //    LOGGER.Info("管制端末へのへヘルスチェック応答を受信できませんでした。");
        //            //    if (m_CarControlStatus == C_UNDER_CONTROL && m_error_flg == C_NORMAL)
        //            //    {
        //            //        EmergencyEndProcess(Res.ErrorStatus.CTRL_HEALTH_SEND_ERR.Code);
        //            //    }
        //            //}

        //        }
        //        catch (Exception ex)
        //        {
        //            if (m_CarControlStatus == C_UNDER_CONTROL)
        //            {
        //                LOGGER.Info("管制端末へのへヘルスチェックを送信に失敗しました。");
        //                EmergencyEndProcess(Res.ErrorStatus.CTRL_HEALTH_SEND_ERR.Code);

        //                //ステータス表示パネル表示
        //                Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_IDLE);
        //                m_EmergencyStop = false;
        //            }
        //            AppLog.GetInstance().Error(ex.Message);
        //            AppLog.GetInstance().Error(ex.StackTrace);
        //        }
        //        finally
        //        {
        //            if (m_timer_mhc_snd != null) { m_timer_mhc_snd.Change(m_ConfigConst.C_MHT_INTERVAL, m_ConfigConst.C_MHT_INTERVAL); }
        //        }
        //    }
        //}

        //private string TerminalHealthCheck()
        //{
        //    //制御していないときのみ開始できるか確認する
        //    if (m_CarControlStatus == C_NOT_IN_CONTROL)
        //    {
        //        string status = Res.CtrlStatus.CTRL_AVAILABLE.Code;

        //        //画像接続確認
        //        if (m_pcl_flag == 0) { return Res.CtrlStatus.CAM_CONNECTION_ERR.Code; }

        //        //カメラ確認
        //        if (m_camht_status == 1) { return Res.CtrlStatus.CAM_ERR.Code; }

        //        //車両接続確認
        //        if (m_tcl_flag == 0 || m_tsrv_flag == 0) { return Res.CtrlStatus.CAR_CONNECTION_ERR.Code; }

        //        //走行停止中か
        //        if (m_EmergencyStop) { return Res.CtrlStatus.STOPPING.Code; }

        //        return status;
        //    }

        //    if (m_CarControlStatus == C_UNDER_CONTROL)
        //    {
        //        if (m_pause_flg == 1 || m_pause_commP_flg >= 1 || m_pause_commT_flg == 1 || m_pause_goal_flg == C_ABNORMAL || m_pause_tvecs_control_state_flg == C_ABNORMAL)
        //        {
        //            if (m_CarInfo.speed == 0)
        //            {
        //                StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_PAUSE);
        //                return Res.CtrlStatus.PAUSED.Code;
        //            }
        //            else
        //            {
        //                StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_PAUSE);
        //                return Res.CtrlStatus.PAUSING.Code;
        //            }
        //        }
        //        else
        //        {
        //            StatusPanelChange(UserStatusPanel.C_PANEL_STATUS_RUNNING);
        //        }
        //    }

        //    return m_TerminalStatus;
        //}

        //private void StatusPanelChange(int code)
        //{
        //    UserStatusPanel.StatusDisplay status = panel_Status.GetCurrentStatusDisplay();
        //    if (status.statusCode != code)
        //    {
        //        Invoke(new Action<int>(panel_status_change), code);
        //    }
        //}

        //private void Master_HealthCheck_TimeOut(object state)
        //{
        //    string msg = $"ヘルスチェックの受信時間を超過しました。";

        //    if (m_error_flg == C_NORMAL && m_CarControlStatus == C_UNDER_CONTROL)
        //    {
        //        LOGGER.Info($"[管制端末]{msg}走行停止します。");
        //        m_logform.mlog_Insert($"{msg}走行停止します。");
        //        EmergencyEndProcess(Res.ErrorStatus.CTRL_HEALTH_SEND_ERR.Code);

        //        //ステータス表示パネル表示
        //        Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_IDLE);
        //        m_EmergencyStop = false;
        //    }
        //    else
        //    {
        //        LOGGER.Info($"[管制端末]{msg}");
        //        m_logform.mlog_Insert($"{msg}");
        //    }
        //}
        //#endregion

        //#region その他エリアチェック
        ///// <summary>
        ///// その他エリアの範囲チェックを行う
        ///// </summary>
        //private void OtherAreaCheck()
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        //その他エリアの数処理
        //        //Parallel.For(0, m_otherArea.Count(), i =>
        //        //{
        //        //    Task task = Task.Run(() => CheckTimer(i));
        //        //});
        //        foreach (OtherAreaRetention i in m_otherArea)
        //        {
        //            Task.Run(() => CheckTimer(i));
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex) { ExceptionProcess.ComnExceptionConsoleProcess(ex); }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        //private async void CheckTimer(OtherAreaRetention i)
        //{
        //    try
        //    {
        //        switch (i.otherarea.AreaCode)
        //        {
        //            case OtherAreaCode.GoalArea:
        //                while (m_CarControlStatus == C_UNDER_CONTROL && i.Done != C_FACILITY_FIN)
        //                {
        //                    if (i.otherarea.Number == m_ConfigData.GoalNo)
        //                    {
        //                        GoalAreaCheck(i);
        //                    }
        //                    await Task.Delay(C_OA_INTERVAL).ConfigureAwait(false);
        //                }
        //                break;
        //            case OtherAreaCode.TakeoverArea:
        //                while (m_CarControlStatus == C_UNDER_CONTROL && i.Done != C_FACILITY_FIN)
        //                {
        //                    TakeoverAreaCheck(i);
        //                    await Task.Delay(C_OA_INTERVAL).ConfigureAwait(false);
        //                }
        //                break;
        //            case OtherAreaCode.FacilityArea:
        //                while (m_CarControlStatus == C_UNDER_CONTROL && i.Done != C_FACILITY_FIN)
        //                {
        //                    FacilityAreaCheck(i);
        //                    await Task.Delay(C_OA_INTERVAL).ConfigureAwait(false);
        //                }
        //                break;
        //            case OtherAreaCode.GoalChangeStopArea:
        //                while (m_CarControlStatus == C_UNDER_CONTROL && i.Done != C_FACILITY_FIN)
        //                {
        //                    GoalChangeStopAreaCheck(i);
        //                    await Task.Delay(C_OA_INTERVAL).ConfigureAwait(false);
        //                }
        //                break;
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        ExceptionProcess.ComnExceptionConsoleProcess(ex);

        //        if (m_CarControlStatus == C_UNDER_CONTROL)
        //        {
        //            m_logform.mlog_Insert($"原因不明のエラーにより走行停止します");
        //            EmergencyEndProcess(Res.ErrorStatus.LOOKINGFOR_ERR.Code);
        //        }
        //    }
        //    finally { }
        //}

        //#region GoalAreaCheck（ゴールエリアの判定を行う）
        ///// <summary>
        ///// ゴールエリアの判定を行う
        ///// </summary>
        ///// <param name="i"></param>
        //private void GoalAreaCheck(OtherAreaRetention i)
        //{
        //    //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
        //    if (m_carstarted == 0 || m_camstarted == 0) { return; }

        //    int idx = i.Done;
        //    if (Viewer.PositionInArea(i.otherarea.area[idx]))
        //    {
        //        //管制端末からの指示とゴール番号が同じであればゴールと判定
        //        if (i.otherarea.Number == m_ConfigData.GoalNo)
        //        {
        //            LOGGER.Info("ゴールエリアに侵入しました。");
        //            //ゴールフラグを立て、車両状態通知で速度0が来るのを待つ
        //            m_evGoalRcvWait.Reset();
        //            m_goal_flg = 1;
        //            m_senser_check = i.otherarea.Sensor;
        //        }
        //        m_TerminalStatus = Res.CtrlStatus.ARRV_GOAL_AREA.Code;
        //        i.Done = C_FACILITY_FIN;

        //        //車両の停車と在籍センサの待機を待つ
        //        if (i.otherarea.Sensor)
        //        {
        //            //受信待機
        //            if (m_evGoalRcvWait.WaitOne(m_ConfigConst.C_SENSORCHECK_DELAY))
        //            {
        //                string msg = "";
        //                if (i.otherarea.Number < m_ConfigData.GoalNo)
        //                {
        //                    msg = "在籍センサの検知を確認しました";
        //                    LOGGER.Info($"{msg}。{m_ConfigData.GoalNo}:{m_ConfigData.GoalNo}");
        //                    m_logform.mlog_Insert(msg);
        //                    Task.Run(() => EndProcess());
        //                }
        //                else
        //                {
        //                    msg = $"在籍センサで検知できません。走行停止します";
        //                    LOGGER.Info($"{msg}。{m_ConfigData.GoalNo}:{m_ConfigData.GoalNo}");
        //                    m_logform.mlog_Insert(msg);
        //                    EmergencyEndProcess(Res.ErrorStatus.P_ERR.Code);
        //                }
        //            }
        //            else
        //            {
        //                LOGGER.Info($"在籍エリア応答(ゴール変更通知)を受信できません。走行停止します。");
        //                EmergencyEndProcess(Res.ErrorStatus.P_ERR.Code);
        //            }
        //        }
        //    }
        //}
        //#endregion

        //#region TakeoverAreaCheck（引継ぎエリアの判定を行う）
        ///// <summary>
        ///// 引継ぎエリアの判定を行う
        ///// </summary>
        ///// <param name="i"></param>
        //private void TakeoverAreaCheck(OtherAreaRetention i)
        //{
        //    //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
        //    if (m_carstarted == 0 || m_camstarted == 0) { return; }

        //    int idx = i.Done;
        //    if (Viewer.PositionInArea(i.otherarea.area[idx]))
        //    {
        //        SndTakeoverInquiry sndmsg = new SndTakeoverInquiry();
        //        sndmsg.CarNo = m_CarNo;
        //        string rcvmsg = "";

        //        for (int count = 1; count <= C_RETRYCOUNT; count++)
        //        {
        //            try
        //            {
        //                LOGGER.Info($"[管制端末]送信→引継確認通知");
        //                m_logform.mlog_Insert($"送信→引継確認通知");
        //                rcvmsg = m_mcl.SendMessage(sndmsg, m_ConfigConst.C_SNDRSESULT_MNG);
        //                if (m_ConfigConst.C_SNDRSESULT_MNG && rcvmsg == null) { throw new Exception(); }
        //                i.Done = C_FACILITY_FIN;
        //                m_TerminalStatus = Res.CtrlStatus.ON_HAND_OVER.Code;
        //                break;
        //            }
        //            catch
        //            {
        //                if (count == C_RETRYCOUNT)
        //                {
        //                    LOGGER.Info($"引継ぎ確認通知送信失敗。走行停止します。");
        //                    m_logform.mlog_Insert($"引継ぎ確認通知送信失敗。走行停止します。");
        //                    EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //                    return;
        //                }
        //                LOGGER.Info($"引継ぎ確認通知送信失敗。再送信します。");
        //            }
        //        }

        //        if (m_ConfigConst.C_SNDRSESULT_MNG)
        //        {
        //            string msgid = CommMsgBase.GetMsgID(rcvmsg);
        //            RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvmsg);
        //            if (msgid == RcvRsultRcvMsg.msgId)
        //            {
        //                LOGGER.Info($"引継ぎ確認通知応答受信:{rcvmsg}");
        //            }
        //        }
        //    }
        //}
        //#endregion

        //#region FacilityAreaCheck（周辺設備の範囲判定を行う）
        ///// <summary>
        ///// 周辺設備の範囲判定を行う
        ///// </summary>
        ///// <param name="i"></param>
        //private void FacilityAreaCheck(OtherAreaRetention i)
        //{
        //    //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
        //    if (m_carstarted == 0 || m_camstarted == 0) { return; }

        //    int idx = i.Done;
        //    if (Viewer.PositionInArea(i.otherarea.area[idx]))
        //    {
        //        OtherArea area = i.otherarea;
        //        switch (idx)
        //        {
        //            //指示開始エリア
        //            case C_FACILITY_START:
        //                SndFacilityControl sndfcst = new SndFacilityControl();
        //                sndfcst.FacilityID = area.FacilityID;
        //                sndfcst.Command = "1";
        //                string rcvst = "";
        //                for (int count = 1; count <= C_RETRYCOUNT; count++)
        //                {
        //                    try
        //                    {
        //                        rcvst = m_mcl.SendMessage(sndfcst, m_ConfigConst.C_SNDRSESULT_MNG);
        //                        LOGGER.Info($"[管制端末]送信→設備制御指示:{area.FacilityID}.{area.Name}");
        //                        m_logform.mlog_Insert($"送信→設備制御指示:{area.FacilityID}.{area.Name}");
        //                        if (m_ConfigConst.C_SNDRSESULT_MNG && rcvst == null) { throw new Exception(); }
        //                        i.Done = C_FACILITY_CHECK;
        //                        break;
        //                    }
        //                    catch
        //                    {
        //                        if (count == C_RETRYCOUNT)
        //                        {
        //                            LOGGER.Info($"設備制御指示送信失敗。走行停止します。");
        //                            m_logform.mlog_Insert($"設備制御指示送信失敗。走行停止します。");
        //                            EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //                            return;
        //                        }

        //                        LOGGER.Info($"設備制御指示送信失敗。再送信します。");
        //                    }
        //                }
        //                if (m_ConfigConst.C_SNDRSESULT_MNG)
        //                {
        //                    string msgid = CommMsgBase.GetMsgID(rcvst);
        //                    RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvst);
        //                    if (msgid == RcvRsultRcvMsg.msgId)
        //                    {
        //                        LOGGER.Info($"設備制御指示応答受信:{rcvst}");
        //                    }
        //                }

        //                break;
        //            //指示終了エリア
        //            case C_FACILITY_END:
        //                SndFacilityControl sndfcend = new SndFacilityControl();
        //                sndfcend.FacilityID = area.FacilityID;
        //                sndfcend.Command = "0";
        //                string rcvend = "";
        //                for (int count = 1; count <= C_RETRYCOUNT; count++)
        //                {
        //                    try
        //                    {
        //                        rcvend = m_mcl.SendMessage(sndfcend, m_ConfigConst.C_SNDRSESULT_MNG);
        //                        LOGGER.Info($"[管制端末]送信→設備制御指示:{area.FacilityID}.{area.Name}");
        //                        m_logform.mlog_Insert($"送信→設備制御指示:{area.FacilityID}.{area.Name}");
        //                        if (m_ConfigConst.C_SNDRSESULT_MNG && rcvend == null) { throw new Exception(); }
        //                        i.Done = C_FACILITY_FIN;
        //                        break;
        //                    }
        //                    catch
        //                    {
        //                        if (count == C_RETRYCOUNT)
        //                        {
        //                            LOGGER.Info($"設備制御指示送信失敗。走行停止します。");
        //                            m_logform.mlog_Insert($"設備制御指示送信失敗。走行停止します。");
        //                            EmergencyEndProcess(Res.ErrorStatus.FACILITY_ERR.Code);
        //                            return;
        //                        }

        //                        LOGGER.Info($"設備制御指示送信失敗。再送信します。");
        //                    }
        //                }
        //                if (m_ConfigConst.C_SNDRSESULT_MNG)
        //                {
        //                    string msgid = CommMsgBase.GetMsgID(rcvend);
        //                    RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvend);
        //                    if (msgid == RcvRsultRcvMsg.msgId)
        //                    {
        //                        LOGGER.Info($"設備制御指示応答受信:{rcvend}");
        //                    }
        //                }

        //                break;
        //            //指示完了確認エリア
        //            case C_FACILITY_CHECK:
        //                if (i.status == 0)
        //                {
        //                    //if (i.stop == false)
        //                    //{
        //                    //    LOGGER.Info($"設備制御未完了のため一時停止します。設備ID：{i.otherarea.FacilityID}");
        //                    //    m_logform.mlog_Insert($"設備制御未完了のため一時停止します。設備ID：{i.otherarea.FacilityID}");
        //                    //}

        //                    ////動作後でなければ一時停止させる
        //                    //m_pause_flg = 1;
        //                    //m_TerminalStatus = Res.CtrlStatus.WAIT_FACILITY_DONE.Code;
        //                    //i.stop = true;

        //                    LOGGER.Info($"設備制御未完了のため走行停止します。設備：{i.otherarea.FacilityID}.{area.Name}");
        //                    m_logform.mlog_Insert($"設備制御未完了のため走行停止します。設備：{i.otherarea.FacilityID}.{area.Name}");
        //                    EmergencyEndProcess(Res.ErrorStatus.FACILITY_RES_ERR.Code, C_PT_FACILITY, i.otherarea.FacilityID, "1");

        //                }
        //                else
        //                {
        //                    //動作後であれば一時停止せず進める
        //                    i.Done = C_FACILITY_END;
        //                }
        //                break;
        //        }
        //    }
        //    //else if (m_pause_flg == 1 && idx == C_FACILITY_CHECK)
        //    //{
        //    //    //指示完了確認エリアで確認できていないのにエリアを出てしまった後の対処
        //    //    if (i.status == 0)
        //    //    {
        //    //        //動作後でなければ一時停止させる
        //    //        m_pause_flg = 1;
        //    //        m_TerminalStatus = Res.CtrlStatus.WAIT_FACILITY_DONE.Code;
        //    //        i.stop = true;
        //    //    }
        //    //    else
        //    //    {
        //    //        //動作後であれば一時停止せず進める
        //    //        i.Done = C_FACILITY_END;
        //    //    }
        //    //}
        //}
        //#endregion

        //#region GoalChangeStopAreaCheck（ゴールエリア判定通知の送信を行う）
        //private void GoalChangeStopAreaCheck(OtherAreaRetention i)
        //{
        //    //車両通信端末と画像解析装置から電文を取得するまでチェックをしない
        //    if (m_carstarted == 0 || m_camstarted == 0) { return; }

        //    int idx = i.Done;
        //    if (Viewer.PositionInArea(i.otherarea.area[idx]))
        //    {
        //        SndGoalChangeStop sndmsg = new SndGoalChangeStop();

        //        string rcvmsg = "";

        //        for (int count = 1; count <= C_RETRYCOUNT; count++)
        //        {
        //            try
        //            {
        //                LOGGER.Info($"[管制端末]送信→ゴールエリア判定通知");
        //                m_logform.mlog_Insert($"送信→ゴールエリア判定通知");
        //                m_evCheckRcvWait.Reset();
        //                rcvmsg = m_mcl.SendMessage(sndmsg, m_ConfigConst.C_SNDRSESULT_MNG);
        //                if (m_ConfigConst.C_SNDRSESULT_MNG && rcvmsg == null) { throw new Exception(); }
        //                i.Done = C_FACILITY_FIN;
        //                break;
        //            }
        //            catch
        //            {
        //                if (count == C_RETRYCOUNT)
        //                {
        //                    LOGGER.Info($"ゴールエリア判定通知送信失敗。走行停止します。");
        //                    m_logform.mlog_Insert($"ゴール判定エリア通知送信失敗。走行停止します。");
        //                    EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //                    m_evCheckRcvWait.Set();
        //                    return;
        //                }

        //                LOGGER.Info($"ゴールエリア判定通知送信失敗。再送信します。");
        //            }
        //        }

        //        if (m_ConfigConst.C_SNDRSESULT_MNG)
        //        {
        //            string msgid = CommMsgBase.GetMsgID(rcvmsg);
        //            RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvmsg);
        //            if (msgid == RcvRsultRcvMsg.msgId)
        //            {
        //                LOGGER.Info($"ゴールエリア判定通知応答受信:{rcvmsg}");
        //            }
        //        }

        //        //受信確認
        //        if (m_evCheckRcvWait.WaitOne(m_ConfigConst.C_GOALCHECK_DELAY))
        //        {

        //        }
        //        else
        //        {
        //            LOGGER.Info($"ゴールエリア判定結果を受信できません。走行停止します。");
        //            m_logform.mlog_Insert($"ゴールエリア判定結果を受信できません。走行停止します。");
        //            EmergencyEndProcess(Res.ErrorStatus.Q_ERR.Code);
        //        }
        //    }
        //}
        //#endregion

        //#endregion

        //#endregion

        //#region 制御終了処理
        /// <summary>
        /// ゴールセンサ点灯確認
        /// </summary>
        //private void GoalSensorStatusCheck()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    //センサ点灯ディレイ調整
        //    Thread.Sleep(C_SENSOR_DELAY);

        //    SndGoalChangeStop sndmsg = new SndGoalChangeStop();
        //    string rcvmsg = "";
        //    for (int count = 1; count <= C_RETRYCOUNT; count++)
        //    {
        //        try
        //        {
        //            LOGGER.Info($"[管制端末]送信→ゴール判定通知(在籍センサ点灯確認)");

        //            rcvmsg = m_mcl.SendMessage(sndmsg, C_SNDRSESULT_MNG);
        //            if (C_SNDRSESULT_MNG && rcvmsg == null) { throw new Exception(); }
        //            break;
        //        }
        //        catch
        //        {
        //            if (count == C_RETRYCOUNT)
        //            {
        //                LOGGER.Info($"ゴール判定通知送信失敗。走行停止します。");

        //                EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //                return;
        //            }
        //            LOGGER.Info($"ゴール判定通知送信失敗。再送信します。");
        //        }
        //    }

        //    if (m_ConfigConst.C_SNDRSESULT_MNG)
        //    {
        //        string msgid = CommMsgBase.GetMsgID(rcvmsg);
        //        RcvRsultRcvMsg msg = new RcvRsultRcvMsg(rcvmsg);
        //        if (msgid == RcvRsultRcvMsg.msgId)
        //        {
        //            LOGGER.Info($"ゴール判定通知応答受信:{rcvmsg}");
        //        }
        //    }

        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}


        ///// <summary>
        ///// 制御正常終了時の処理を行う
        ///// </summary>
        //private void EndProcess()
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        LOGGER.Info("制御正常終了処理を開始します。");
        //        try
        //        {
        //            // 車両通信装置に制御終了指示を送信する
        //            CarControlEnd();

        //            //測位終了通知を送信する
        //            CamEnd();

        //            //制御終了通知
        //            ControlEndSnd();

        //            // タイマーを止める
        //            TimerEnd();

        //            //すぐ次がスタートできないように待機
        //            Thread.Sleep(5000);

        //            //ステータス表示パネル表示
        //            Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_IDLE);

        //            m_CarControlStatus = C_NOT_IN_CONTROL;

        //            //設定画面有効化
        //            Invoke(new Action(() => SettingOpen.Enabled = true));
        //        }
        //        catch
        //        {
        //            EmergencyEndProcess(Res.ErrorStatus.O_ERR.Code);
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 異常終了時の終了処理を行う(全てに通知)
        ///// </summary>
        //private void EmergencyEndProcess(string errcd, string Pt = null, string arg1 = null, string arg2 = null)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        LOGGER.Info("走行停止終了処理を開始します。");
        //        if (m_error_flg == C_NORMAL)
        //        {
        //            m_error_flg = C_ABNORMAL;

        //            //車両通信装置へ走行停止通知を送信する
        //            if (m_tcl_flag == 1) { Task.Run(() => EmergencyStop()); }

        //            //測位終了通知を送信する
        //            if (m_pcl_flag == 1) { Task.Run(() => CamEnd()); }

        //            //管制に異常を通知
        //            if (Pt == C_PT_FACILITY)
        //            {
        //                if (m_mcl_flag == 1) { FacilityEmergencySnd(arg1, arg2); }
        //            }
        //            else if (Pt == C_PT_CAMHEALTH)
        //            {
        //                if (m_mcl_flag == 1) { EmergencySnd(errcd, arg1, arg2); }
        //            }
        //            else
        //            {
        //                if (m_mcl_flag == 1) { EmergencySnd(errcd); }
        //            }

        //            // タイマーを止める
        //            TimerEnd();

        //            //ステータス表示パネル表示
        //            Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_ERROR);
        //            m_EmergencyStop = true;

        //            m_CarControlStatus = C_NOT_IN_CONTROL;

        //            //設定画面有効化
        //            Invoke(new Action(() => SettingOpen.Enabled = true));
        //        }
        //        else
        //        {
        //            LOGGER.Info("走行停止終了処理開始済み。");
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 車両からの異常通知
        ///// </summary>
        //private void CarEmergencyEnd(string errcd)
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        LOGGER.Info("走行停止終了処理を開始します。");
        //        if (m_error_flg == C_NORMAL)
        //        {
        //            m_error_flg = C_ABNORMAL;

        //            //測位終了通知を送信する
        //            //if (m_pcl.IsConnected) { CamEnd(); }
        //            if (m_pcl_flag == 1) { CamEnd(); }

        //            //管制に異常を通知
        //            //if (m_mcl.IsConnected) { EmergencySnd(errcd); }
        //            if (m_mcl_flag == 1) { EmergencySnd(errcd); }

        //            // タイマーを止める
        //            TimerEnd();

        //            //ステータス表示パネル表示
        //            if (m_CarControlStatus == C_UNDER_CONTROL)
        //            {
        //                //制御中であった場合のみステータスを変更する
        //                Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_ERROR);
        //                m_EmergencyStop = true;
        //            }
        //            else
        //            {
        //                m_error_flg = C_NORMAL;
        //            }

        //            m_CarControlStatus = C_NOT_IN_CONTROL;

        //            //設定画面有効化
        //            Invoke(new Action(() => SettingOpen.Enabled = true));
        //        }
        //        else
        //        {
        //            LOGGER.Info("走行停止終了処理開始済み。");
        //        }

        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 管制端末からの異常通知
        ///// </summary>
        //private void MngEmergencyEnd()
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        LOGGER.Info("走行停止終了処理を開始します。");
        //        if (m_error_flg == C_NORMAL)
        //        {
        //            m_error_flg = C_ABNORMAL;

        //            //車両通信装置へ走行停止通知を送信する
        //            //if (m_tcl.IsConnected) { EmergencyStop(); }
        //            if (m_tcl_flag == 1) { Task.Run(() => EmergencyStop()); }

        //            //測位終了通知を送信する
        //            //if (m_pcl.IsConnected) { CamEnd(); }
        //            if (m_pcl_flag == 1) { CamEnd(); }

        //            // タイマーを止める
        //            TimerEnd();

        //            //ステータス表示パネル表示
        //            Invoke(new Action<int>(panel_status_change), UserStatusPanel.C_PANEL_STATUS_ERROR);
        //            m_EmergencyStop = true;

        //            m_CarControlStatus = C_NOT_IN_CONTROL;

        //            //設定画面有効化
        //            Invoke(new Action(() => SettingOpen.Enabled = true));
        //        }
        //        else
        //        {
        //            LOGGER.Info("走行停止終了処理開始済み。");
        //        }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}

        ///// <summary>
        ///// 制御中に動作しているタイマーを止める
        ///// </summary>
        //private void TimerEnd()
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        // 加速度舵角を送るのをやめる
        //        if (m_timer_cc != null)
        //        {
        //            m_timer_cc.Dispose();
        //            m_timer_cc = null;
        //            LOGGER.Info("加速度舵角送信タイマー停止");
        //        }
        //        //管制端末への車両情報送信を終了する
        //        if (m_timer_ci != null)
        //        {
        //            m_timer_ci.Dispose();
        //            m_timer_ci = null;
        //            LOGGER.Info("車両情報送信タイマー停止");
        //        }

        //        //再描画処理を終了する
        //        if (m_timer_rd != null)
        //        {
        //            m_timer_rd.Dispose();
        //            m_timer_rd = null;
        //            LOGGER.Info("再描画タイマー停止");
        //        }

        //        if (m_ConfigConst.C_SURVEILLANCE_CAM)
        //        {
        //            //画像解析装置受信間隔
        //            if (m_timer_pRcv_pause != null)
        //            {
        //                m_timer_pRcv_pause.Dispose();
        //                m_timer_pRcv_pause = null;
        //                LOGGER.Info("画像解析装置受信タイマー停止(一時停止)");
        //            }
        //            if (m_timer_pRcv_stop != null)
        //            {
        //                m_timer_pRcv_stop.Dispose();
        //                m_timer_pRcv_stop = null;
        //                LOGGER.Info("画像解析装置受信タイマー停止(走行停止)");
        //            }
        //        }
        //        if (m_ConfigConst.C_SURVEILLANCE_CAR)
        //        {
        //            //車両通信装置受信間隔
        //            if (m_timer_tRcv_pause != null)
        //            {
        //                m_timer_tRcv_pause.Dispose();
        //                m_timer_tRcv_pause = null;
        //                LOGGER.Info("車両通信装置受信タイマー停止(一時停止)");
        //            }
        //            if (m_timer_tRcv_stop != null)
        //            {
        //                m_timer_tRcv_stop.Dispose();
        //                m_timer_tRcv_stop = null;
        //                LOGGER.Info("車両通信装置受信タイマー停止(走行停止)");
        //            }
        //        }

        //        //車両前進確認タイマーの停止
        //        if (m_timer_carmove != null)
        //        {
        //            m_timer_carmove.Dispose();
        //            m_timer_carmove = null;
        //            LOGGER.Info("車両前進確認タイマー停止");
        //        }

        //        m_CarControlStatus = C_NOT_IN_CONTROL;

        //        //ログも止める
        //        m_calc.ClsCalculatorClosed();
        //        if (m_RCDLogger != null) { m_RCDLogger.Dispose(); }
        //    }
        //    catch (UserException ue) { ExceptionProcess.UserExceptionProcess(ue); }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //    }
        //    finally { AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End"); }
        //}
        //#endregion

        //#region 初期化
        ///// <summary>
        ///// 値の初期化
        ///// </summary>
        //public void ResetVal_()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //    LOGGER.Info("各種初期化を開始します");



        //    m_CalcInfo.InGoal = false;


        //    m_calcstarted = C_NOT_RECEIVED;

        //    m_ControlStart = 0;
        //    m_goal_flg = 0;
        //    m_goalcomp_flg = 0;
        //    m_senser_check = true;

        //    m_pause_flg = 0;
        //    m_pause_goal_flg = C_NORMAL;


        //    m_errcount = 0;

        //    Viewer.ResetView();
        //    Viewer.SpeedAreaReset((ConfigData)m_ConfigData.Clone());

        //    m_GoalAreaFilled = false;

        //    Invoke(new Action(Viewer.Refresh));
        //    string msg = " ,測位座標x,測位座標y,車載ヨーレートセンサ値 rad,車載ヨーレートセンサ値 deg,カメラ測位値 rad,カメラ測位値 deg,車載ヨーレートセンサ積分値 rad,車載ヨーレートセンサ積分値 deg,調停情報（測位値、積分値）積分値固定,調停後採用値 rad,調停後採用値 deg,前方注視点座標x,前方注視点座標y,目標軌道 横偏差基準座標x,目標軌道 横偏差基準座標y,横偏差,フィードバック制御 比例項,フィードバック制御 微分項,フィードバック制御 積分項,フィードフォワード制御項,目標舵角,実指示舵角,実舵角,目標車速,実車速,目標加減速度,カメラ画像取得時間,車両制御目標値送信時刻,ヨーレート取得時間,車両マスク信頼度,カメラID,ACT4";
        //    LOGGER.Info($"計測項目 ,→{msg}");
        //    if (m_ConfigConst.C_RCDLOGGER_USE)
        //    {
        //        RCDLoggerOpen();
        //        RCDLogger($"計測項目({DateTime.Now.ToString("yyyyMMddHHmmss")}) ,→{msg}");
        //    }
        //    LOGGER.Info($"ff =>,xi,yi,xi+1,yi+1,xi+2,yi+2,xc1,yc1,xc2,yc2,ai,bi,ai+1,bi+1,xcross,ycross,R,FF");

        //    //その他エリア完了フラグ初期化
        //    for (int i = 0; i <= m_ConfigData.OtherAreas.Count() - 1; i++)
        //    {
        //        m_otherArea[i].otherarea = m_ConfigData.OtherAreas[i];
        //        m_otherArea[i].status = 0;
        //        m_otherArea[i].Done = 0;
        //    }


        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}
        //#endregion

        //#region 計算結果ログ出力
        //private StreamWriter m_RCDLogger;
        //private void RCDLoggerOpen()
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    string FileTextType = C_FILE_TEXT_TYPE;
        //    string filename = DateTime.Now.ToString("yyyyMMdd");
        //    int filenamecount = 0;
        //    bool opened = false;
        //    do
        //    {
        //        try
        //        {
        //            if (filenamecount == 0)
        //            {
        //                m_RCDLogger = new StreamWriter($"{m_ConfigConst.C_RCDLOGGER_PATH}\\{filename}.log", true, System.Text.Encoding.GetEncoding(FileTextType));
        //            }
        //            else
        //            {
        //                m_RCDLogger = new StreamWriter($"{m_ConfigConst.C_RCDLOGGER_PATH}\\{filename}_{filenamecount}.log", true, System.Text.Encoding.GetEncoding(FileTextType));
        //            }
        //            opened = true;
        //        }
        //        catch (Exception e)
        //        {
        //            LOGGER.Error($"{e.Message}");
        //            filenamecount++;
        //            if (filenamecount >= 10)
        //            {
        //                opened = true;
        //            }
        //        }
        //    } while (!opened);
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}

        //private void RCDLogger(string str)
        //{
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");
        //    try
        //    {
        //        m_RCDLogger.WriteLine(str);
        //    }
        //    catch (Exception e)
        //    {
        //        LOGGER.Error($"{e.Message}");
        //    }
        //    AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //}
        //#endregion

        //#region ゴールエリア空き待機
        //private void GoalChangeResend()
        //{
        //    try
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} Start");

        //        int max = m_ConfigConst.C_GOALCHECK_MAXTIME / m_ConfigConst.C_GOALCHECK_INTERVAL;
        //        int cnt = 0;

        //        while (m_CarControlStatus == C_UNDER_CONTROL)
        //        {
        //            //待機
        //            Thread.Sleep(m_ConfigConst.C_GOALCHECK_INTERVAL);
        //            cnt++;

        //            //送信
        //            SndGoalChangeStop sndmsg = new SndGoalChangeStop();
        //            LOGGER.Info($"[管制端末]送信→ゴールエリア判定通知");
        //            m_logform.mlog_Insert($"送信→ゴールエリア判定通知");
        //            m_evCheckRcvWait.Reset();
        //            m_mcl.SendMessage(sndmsg, m_ConfigConst.C_SNDRSESULT_MNG);

        //            //受信確認
        //            if (m_evCheckRcvWait.WaitOne(m_ConfigConst.C_GOALCHECK_DELAY))
        //            {
        //                if (!m_GoalAreaFilled)
        //                {
        //                    //ゴールエリアが空いたとき
        //                    m_pause_goal_flg = C_NORMAL;
        //                    m_GoalAreaFilled = false;
        //                    string msg = $"ゴールエリアが空きました。走行再開します";
        //                    LOGGER.Info(msg);
        //                    m_logform.mlog_Insert(msg);
        //                    break;
        //                }
        //            }
        //            else
        //            {
        //                LOGGER.Info($"ゴールエリア判定結果を受信できません。走行停止します。");
        //                m_logform.mlog_Insert($"ゴールエリア判定結果を受信できません。走行停止します。");
        //                EmergencyEndProcess(Res.ErrorStatus.Q_ERR.Code);
        //            }

        //            if (cnt >= max)
        //            {
        //                string msg = $"ゴールエリアが空きません。走行停止します";
        //                LOGGER.Info(msg);
        //                m_logform.mlog_Insert(msg);
        //                EmergencyEndProcess(Res.ErrorStatus.E_ERR.Code);
        //            }
        //        }

        //    }
        //    catch (Exception ex)
        //    {
        //        AppLog.GetInstance().Error(ex.Message);
        //        AppLog.GetInstance().Error(ex.StackTrace);
        //        //予期せぬエラーで走行停止
        //        EmergencyEndProcess(Res.ErrorStatus.UNKNOWN_ERR.Code);
        //    }
        //    finally
        //    {
        //        AppLog.GetInstance().Debug($"{MethodBase.GetCurrentMethod().Name} End");
        //    }
        //}
        //#endregion

        #endregion


        #region EmergencyEndProcessEventArgsクラス
        public class EmergencyEndProcessEventArgs
        {
            public string errcd;
            public string errtype = null;
            public string arg1 = "0000";
            public string arg2 = "0";
        }
        #endregion

        #region AnalyzerCamNoChangedEventArgsクラス
        public class AnalyzerCamNoChangedEventArgs
        {
            public OperationConst.CamType camtype;
            public string camid;
        }


        #endregion

    }

}
